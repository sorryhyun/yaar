#!/usr/bin/env node
/**
 * Build standalone executable with frontend assets embedded via Bun.
 *
 * Usage:
 *   node scripts/build-exe-bundle.js --provider claude --target windows
 *   node scripts/build-exe-bundle.js --provider codex --target linux
 *
 * Generates a temporary entry point that imports all frontend dist files
 * using `with { type: "file" }`, which tells Bun to embed them as-is
 * (without parsing HTML/CSS/JS). At runtime they're accessible via
 * `Bun.embeddedFiles`.
 */

import { execSync } from 'child_process';
import { readdirSync, writeFileSync, unlinkSync, existsSync } from 'fs';
import { join, dirname, relative, basename } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = join(__dirname, '..');

// ── Parse CLI args ───────────────────────────────────────────────────

const args = process.argv.slice(2);
function getArg(name) {
  const idx = args.indexOf(`--${name}`);
  if (idx === -1 || idx + 1 >= args.length) return undefined;
  return args[idx + 1];
}

const provider = getArg('provider') ?? 'claude';
const target = getArg('target') ?? 'linux';

if (!['claude', 'codex'].includes(provider)) {
  console.error(`Invalid provider: ${provider}. Use "claude" or "codex".`);
  process.exit(1);
}

const bunTargets = {
  windows: 'bun-windows-x64',
  linux: 'bun-linux-x64',
  macos: 'bun-darwin-x64',
};

const bunTarget = bunTargets[target];
if (!bunTarget) {
  console.error(`Invalid target: ${target}. Use "windows", "linux", or "macos".`);
  process.exit(1);
}

const ext = target === 'windows' ? '.exe' : '';
const outfile = join(rootDir, 'dist', `yaar-${provider}${ext}`);

// ── Collect frontend dist files ──────────────────────────────────────

const frontendDist = join(rootDir, 'packages', 'frontend', 'dist');

function collectFiles(dir) {
  const files = [];
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const full = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...collectFiles(full));
    } else {
      files.push(full);
    }
  }
  return files;
}

let frontendFiles;
try {
  frontendFiles = collectFiles(frontendDist);
} catch {
  console.error(`Frontend dist not found at ${frontendDist}`);
  console.error('Run "pnpm build" first.');
  process.exit(1);
}

console.log(`Embedding ${frontendFiles.length} frontend files into ${provider} executable...`);

// ── Collect pre-bundled library files ────────────────────────────────

const bundledLibsDir = join(rootDir, 'dist', 'bundled-libs');
let bundledLibFiles = [];

if (existsSync(bundledLibsDir)) {
  bundledLibFiles = readdirSync(bundledLibsDir)
    .filter(f => f.endsWith('.js'))
    .map(f => ({ name: basename(f, '.js'), absPath: join(bundledLibsDir, f) }));
  console.log(`Embedding ${bundledLibFiles.length} bundled libraries...`);
} else {
  console.warn('Warning: dist/bundled-libs/ not found. Run "pnpm build:exe:libs" first.');
  console.warn('Bundled exe will not be able to resolve @bundled/* imports at runtime.');
}

// ── Generate temporary entry point ──────────────────────────────────

const generatedEntry = join(rootDir, 'packages', 'server', 'src', `_build-entry-${provider}.generated.ts`);
const serverSrcDir = join(rootDir, 'packages', 'server', 'src');

// Build import lines for each frontend file using { type: "file" }
// so Bun embeds them as-is without parsing HTML/CSS/JS.
// Each import returns a /$bunfs/ path at runtime; we map URL paths to these.
const importLines = [];
const mapEntries = [];

frontendFiles.forEach((absPath, i) => {
  // Relative path from generated file to frontend file (posix separators)
  const rel = relative(serverSrcDir, absPath).split('\\').join('/');
  const importPath = rel.startsWith('.') ? rel : `./${rel}`;
  importLines.push(`import _f${i} from ${JSON.stringify(importPath)} with { type: "file" };`);

  // URL path: strip frontendDist prefix → e.g. "/index.html", "/assets/index-xxx.js"
  const urlPath = '/' + relative(frontendDist, absPath).split('\\').join('/');
  mapEntries.push(`  ${JSON.stringify(urlPath)}: _f${i},`);
});

// Build import lines for each bundled library file
const libImportLines = [];
const libMapEntries = [];

bundledLibFiles.forEach(({ name, absPath }, i) => {
  const rel = relative(serverSrcDir, absPath).split('\\').join('/');
  const importPath = rel.startsWith('.') ? rel : `./${rel}`;
  libImportLines.push(`import _lib${i} from ${JSON.stringify(importPath)} with { type: "file" };`);
  libMapEntries.push(`  ${JSON.stringify(name)}: _lib${i},`);
});

const generatedSource = [
  '// @ts-nocheck',
  '// Auto-generated by build-exe-bundle.js — do not edit',
  '',
  ...importLines,
  ...libImportLines,
  '',
  '// Map URL paths to embedded file paths (/$bunfs/root/...)',
  '(globalThis as any).__YAAR_EMBEDDED_FRONTEND = {',
  ...mapEntries,
  '};',
  '',
  ...(libMapEntries.length > 0 ? [
    '// Map library names to embedded file paths for @bundled/* resolution',
    '(globalThis as any).__YAAR_BUNDLED_LIBS = {',
    ...libMapEntries,
    '};',
    '',
  ] : []),
  `process.env.PROVIDER = ${JSON.stringify(provider)};`,
  `import './exe-entry.js';`,
  '',
].join('\n');

writeFileSync(generatedEntry, generatedSource, 'utf-8');

// ── Build ────────────────────────────────────────────────────────────

const entrypoint = relative(rootDir, generatedEntry);
const cmd = [
  'bun', 'build',
  entrypoint,
  '--compile',
  `--target=${bunTarget}`,
  `--outfile=${relative(rootDir, outfile)}`,
  '--minify',
  '--define', '__YAAR_BUNDLED=true',
].join(' ');

console.log(`Running: ${cmd.slice(0, 120)}...`);

try {
  execSync(cmd, { cwd: rootDir, stdio: 'inherit' });
  console.log(`\nBuilt: ${outfile}`);
} finally {
  // Clean up generated entry point
  try { unlinkSync(generatedEntry); } catch { /* ignore */ }
}
