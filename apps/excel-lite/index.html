<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Excel Lite</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  </style>
  <script>
(function() {
  if (window.__yaarCaptureInstalled) return;
  window.__yaarCaptureInstalled = true;

  window.addEventListener('message', function(e) {
    if (!e.data || e.data.type !== 'yaar:capture-request') return;
    var requestId = e.data.requestId;
    var imageData = null;

    try {
      // Try capturing the largest canvas element
      var canvases = document.querySelectorAll('canvas');
      if (canvases.length > 0) {
        var largest = null;
        var largestArea = 0;
        for (var i = 0; i < canvases.length; i++) {
          var area = canvases[i].width * canvases[i].height;
          if (area > largestArea) {
            largestArea = area;
            largest = canvases[i];
          }
        }
        if (largest) {
          imageData = largest.toDataURL('image/png');
        }
      }

      // Fall back to SVG capture
      if (!imageData) {
        var svgs = document.querySelectorAll('svg');
        if (svgs.length > 0) {
          var largest = null;
          var largestArea = 0;
          for (var i = 0; i < svgs.length; i++) {
            var rect = svgs[i].getBoundingClientRect();
            var area = rect.width * rect.height;
            if (area > largestArea) {
              largestArea = area;
              largest = svgs[i];
            }
          }
          if (largest) {
            var serializer = new XMLSerializer();
            var svgStr = serializer.serializeToString(largest);
            var rect = largest.getBoundingClientRect();
            var w = rect.width || 300;
            var h = rect.height || 150;
            var img = new Image();
            var blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
            var url = URL.createObjectURL(blob);
            img.onload = function() {
              var c = document.createElement('canvas');
              c.width = w;
              c.height = h;
              var ctx = c.getContext('2d');
              ctx.drawImage(img, 0, 0, w, h);
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: c.toDataURL('image/png')
              }, '*');
            };
            img.onerror = function() {
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: null
              }, '*');
            };
            img.src = url;
            return; // async path â€” response sent from onload/onerror
          }
        }
      }
    } catch (ex) {
      // Capture failed, imageData stays null
    }

    window.parent.postMessage({
      type: 'yaar:capture-response',
      requestId: requestId,
      imageData: imageData
    }, '*');
  });
})();
</script>
</head>
<body>
  <script type="module">
// ../../sandbox/1770554446087/src/constants.ts
var ROWS = 60;
var COLS = 20;
var DEFAULT_STYLE = {
  bold: false,
  italic: false,
  underline: false,
  fontSize: 14,
  color: "#111827",
  bg: "#ffffff",
  align: "left"
};

// ../../sandbox/1770554446087/src/data-utils.ts
function cloneMap(map) {
  return JSON.parse(JSON.stringify(map));
}
function csvEscape(value) {
  if (/[\",\n]/.test(value)) return `"${value.replace(/"/g, '""')}"`;
  return value;
}

// ../../sandbox/1770554446087/src/ref-utils.ts
function colLabel(n) {
  let s = "";
  let x = n;
  while (x > 0) {
    const r = (x - 1) % 26;
    s = String.fromCharCode(65 + r) + s;
    x = Math.floor((x - 1) / 26);
  }
  return s;
}
function colNumber(label) {
  let c = 0;
  for (const ch of label) c = c * 26 + (ch.charCodeAt(0) - 64);
  return c;
}
function key(c, r) {
  return `${colLabel(c)}${r}`;
}
function parseRef(ref) {
  const m = ref.toUpperCase().match(/^([A-Z]+)(\d+)$/);
  if (!m) return null;
  return { c: colNumber(m[1]), r: Number(m[2]) };
}
function rangeRect(a, b) {
  const p1 = parseRef(a);
  const p2 = parseRef(b);
  return {
    c1: Math.min(p1.c, p2.c),
    c2: Math.max(p1.c, p2.c),
    r1: Math.min(p1.r, p2.r),
    r2: Math.max(p1.r, p2.r)
  };
}
function refsInRect(rect) {
  const out = [];
  for (let r = rect.r1; r <= rect.r2; r++) {
    for (let c = rect.c1; c <= rect.c2; c++) out.push(key(c, r));
  }
  return out;
}
function expandRange(a, b) {
  const p1 = parseRef(a);
  const p2 = parseRef(b);
  if (!p1 || !p2) return [];
  const out = [];
  const c1 = Math.min(p1.c, p2.c);
  const c2 = Math.max(p1.c, p2.c);
  const r1 = Math.min(p1.r, p2.r);
  const r2 = Math.max(p1.r, p2.r);
  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) out.push(key(c, r));
  }
  return out;
}

// ../../sandbox/1770554446087/src/fill-utils.ts
function computeFillDestination(source, targetRef) {
  const t = parseRef(targetRef);
  if (!t) return null;
  const up = t.r < source.r1;
  const down = t.r > source.r2;
  const left = t.c < source.c1;
  const right = t.c > source.c2;
  if (!up && !down && !left && !right) return null;
  const rowDist = up ? source.r1 - t.r : down ? t.r - source.r2 : 0;
  const colDist = left ? source.c1 - t.c : right ? t.c - source.c2 : 0;
  if ((up || down) && rowDist >= colDist) {
    return up ? { c1: source.c1, c2: source.c2, r1: t.r, r2: source.r1 - 1 } : { c1: source.c1, c2: source.c2, r1: source.r2 + 1, r2: t.r };
  }
  return left ? { c1: t.c, c2: source.c1 - 1, r1: source.r1, r2: source.r2 } : { c1: source.c2 + 1, c2: t.c, r1: source.r1, r2: source.r2 };
}
function sourceForDestination(source, destRef) {
  const p = parseRef(destRef);
  const h = source.r2 - source.r1 + 1;
  const w = source.c2 - source.c1 + 1;
  let sr = source.r1;
  let sc = source.c1;
  if (p.r > source.r2) sr = source.r1 + (p.r - source.r1) % h;
  else if (p.r < source.r1) sr = source.r2 - (source.r1 - p.r - 1) % h;
  else sr = p.r;
  if (p.c > source.c2) sc = source.c1 + (p.c - source.c1) % w;
  else if (p.c < source.c1) sc = source.c2 - (source.c1 - p.c - 1) % w;
  else sc = p.c;
  return key(sc, sr);
}

// ../../sandbox/1770554446087/src/formula-utils.ts
function createFormulaEngine(getRaw2) {
  function evalCell(ref, seen = /* @__PURE__ */ new Set()) {
    if (seen.has(ref)) return NaN;
    seen.add(ref);
    const raw = getRaw2(ref).trim();
    if (!raw) return 0;
    if (!raw.startsWith("=")) {
      const n = Number(raw);
      return Number.isFinite(n) ? n : NaN;
    }
    return evalFormula(raw.slice(1), seen);
  }
  function evalFormula(expr, seen) {
    try {
      let safe = expr.toUpperCase();
      safe = safe.replace(/SUM\(\s*([A-Z]+\d+)\s*:\s*([A-Z]+\d+)\s*\)/g, (_, a, b) => {
        return String(
          expandRange(a, b).reduce((acc, ref) => {
            const v = evalCell(ref, new Set(seen));
            return acc + (Number.isFinite(v) ? v : 0);
          }, 0)
        );
      });
      safe = safe.replace(/\b([A-Z]+\d+)\b/g, (_, ref) => {
        const v = evalCell(ref, new Set(seen));
        return Number.isFinite(v) ? String(v) : "NaN";
      });
      if (!/^[0-9+\-*/().\sNAN]+$/.test(safe)) return NaN;
      const result = Function(`"use strict"; return (${safe});`)();
      return Number.isFinite(result) ? result : NaN;
    } catch {
      return NaN;
    }
  }
  function display(ref) {
    const raw = getRaw2(ref);
    if (!raw.startsWith("=")) return raw;
    const v = evalCell(ref);
    return Number.isFinite(v) ? String(v) : "#ERR";
  }
  return { evalCell, display };
}
function shiftFormula(raw, rowShift, colShift) {
  if (!raw.startsWith("=")) return raw;
  return raw.replace(/\b([A-Z]+)(\d+)\b/g, (_, letters, rowNum) => {
    const c = Math.max(1, colNumber(letters) + colShift);
    const r = Math.max(1, Number(rowNum) + rowShift);
    return `${colLabel(c)}${r}`;
  });
}

// ../../sandbox/1770554446087/src/history-utils.ts
function pushHistorySnapshot(history2, future2, cells2, styles2, limit = 100) {
  history2.push({ cells: cloneMap(cells2), styles: cloneMap(styles2) });
  if (history2.length > limit) history2.shift();
  future2.length = 0;
}
function applySnapshotToMaps(snapshot, cells2, styles2) {
  for (const k of Object.keys(cells2)) delete cells2[k];
  for (const [k, v] of Object.entries(snapshot.cells)) cells2[k] = v;
  for (const k of Object.keys(styles2)) delete styles2[k];
  for (const [k, v] of Object.entries(snapshot.styles)) styles2[k] = v;
}

// ../../sandbox/1770554446087/src/style-utils.ts
function getStyleForRef(styles2, ref) {
  const s = styles2[ref] ?? {};
  return {
    bold: s.bold ?? DEFAULT_STYLE.bold,
    italic: s.italic ?? DEFAULT_STYLE.italic,
    underline: s.underline ?? DEFAULT_STYLE.underline,
    fontSize: s.fontSize ?? DEFAULT_STYLE.fontSize,
    color: s.color ?? DEFAULT_STYLE.color,
    bg: s.bg ?? DEFAULT_STYLE.bg,
    align: s.align ?? DEFAULT_STYLE.align
  };
}
function normalizeStyle(style) {
  const normalized = {};
  if ((style.bold ?? DEFAULT_STYLE.bold) !== DEFAULT_STYLE.bold) normalized.bold = !!style.bold;
  if ((style.italic ?? DEFAULT_STYLE.italic) !== DEFAULT_STYLE.italic) normalized.italic = !!style.italic;
  if ((style.underline ?? DEFAULT_STYLE.underline) !== DEFAULT_STYLE.underline) normalized.underline = !!style.underline;
  if ((style.fontSize ?? DEFAULT_STYLE.fontSize) !== DEFAULT_STYLE.fontSize) normalized.fontSize = style.fontSize;
  if ((style.color ?? DEFAULT_STYLE.color) !== DEFAULT_STYLE.color) normalized.color = style.color;
  if ((style.bg ?? DEFAULT_STYLE.bg) !== DEFAULT_STYLE.bg) normalized.bg = style.bg;
  if ((style.align ?? DEFAULT_STYLE.align) !== DEFAULT_STYLE.align) normalized.align = style.align;
  return Object.keys(normalized).length ? normalized : null;
}

// ../../sandbox/1770554446087/src/main.ts
var app = document.createElement("div");
app.innerHTML = `
  <style>
    :root { color-scheme: light; }
    body { margin: 0; font-family: Inter, Arial, sans-serif; background: #f5f7fb; user-select: none; }
    .wrap { padding: 10px; display: grid; gap: 8px; }
    .bar { display: grid; grid-template-columns: auto 1fr auto auto auto auto auto auto auto auto auto auto auto; gap: 6px; align-items: center; }
    .name { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-weight: 600; min-width: 74px; text-align: center; border: 1px solid #d0d7e2; border-radius: 8px; padding: 7px 8px; background: white; }
    input, select { padding: 7px 8px; border: 1px solid #d0d7e2; border-radius: 8px; font-size: 13px; background: white; }
    #formulaInput { width: 100%; }
    button { padding: 7px 10px; border: 1px solid #ccd3df; border-radius: 8px; background: white; cursor: pointer; }
    button:hover { background: #f1f4f9; }
    button.active { background: #dbe8ff; border-color: #96b6ff; }
    .sheetWrap { overflow: auto; border: 1px solid #d9e0ec; border-radius: 10px; background: white; max-height: calc(100vh - 110px); }
    table { border-collapse: collapse; min-width: 1250px; table-layout: fixed; }
    th, td { border: 1px solid #e7ecf5; }
    th { position: sticky; top: 0; background: #f8faff; z-index: 2; font-weight: 600; }
    .rowHead { position: sticky; left: 0; background: #f8faff; z-index: 1; text-align: right; padding: 6px 8px; min-width: 46px; }
    .corner { position: sticky; left: 0; top: 0; z-index: 3; background: #eef3ff; min-width: 46px; }
    td { position: relative; min-width: 98px; }
    td input { width: 100%; border: none; padding: 7px 8px; box-sizing: border-box; outline: none; background: transparent; }
    td.selected { background: #edf3ff; }
    td.active { box-shadow: inset 0 0 0 2px #2a6df6; z-index: 1; }
    .fill-handle { position: absolute; width: 8px; height: 8px; right: -4px; bottom: -4px; border-radius: 1px; background: #2a6df6; cursor: crosshair; z-index: 5; }
    td.fill-preview { background: #cfe1ff; }
    .hint { color: #5c6475; font-size: 12px; }
  </style>
  <div class="wrap">
    <div class="bar">
      <div class="name" id="cellName">A1</div>
      <input id="formulaInput" placeholder="Value or formula (=A1+B1, =SUM(A1:A10))" />
      <button id="boldBtn"><b>B</b></button>
      <button id="italicBtn"><i>I</i></button>
      <button id="underlineBtn"><u>U</u></button>
      <select id="fontSizeSel">
        <option value="12">12</option><option value="14" selected>14</option><option value="16">16</option><option value="18">18</option><option value="20">20</option><option value="24">24</option>
      </select>
      <input id="textColor" type="color" value="#111827" title="Text color" />
      <input id="bgColor" type="color" value="#ffffff" title="Cell background" />
      <select id="alignSel"><option value="left">Left</option><option value="center">Center</option><option value="right">Right</option></select>
      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>
      <button id="saveBtn">Save</button>
      <button id="loadBtn">Load</button>
      <button id="csvBtn">CSV</button>
    </div>
    <div class="hint">Drag to select cells. Drag blue corner to fill. Shift+click extends selection. Ctrl+B/I/U, Ctrl+Z/Y, Delete supported.</div>
    <div class="sheetWrap" id="sheet"></div>
  </div>
`;
document.body.appendChild(app);
var sheetEl = document.getElementById("sheet");
var formulaInput = document.getElementById("formulaInput");
var cellName = document.getElementById("cellName");
var boldBtn = document.getElementById("boldBtn");
var italicBtn = document.getElementById("italicBtn");
var underlineBtn = document.getElementById("underlineBtn");
var fontSizeSel = document.getElementById("fontSizeSel");
var textColor = document.getElementById("textColor");
var bgColor = document.getElementById("bgColor");
var alignSel = document.getElementById("alignSel");
var undoBtn = document.getElementById("undoBtn");
var redoBtn = document.getElementById("redoBtn");
var saveBtn = document.getElementById("saveBtn");
var loadBtn = document.getElementById("loadBtn");
var csvBtn = document.getElementById("csvBtn");
var cells = {};
var styles = {};
var inputs = /* @__PURE__ */ new Map();
var tds = /* @__PURE__ */ new Map();
var fillHandle = document.createElement("div");
fillHandle.className = "fill-handle";
var selected = "A1";
var selectionStart = "A1";
var selectionEnd = "A1";
var editingRef = null;
var isSelecting = false;
var isFillDragging = false;
var fillSource = null;
var fillTarget = null;
var history = [];
var future = [];
function getRaw(ref) {
  return cells[ref] ?? "";
}
var formulaEngine = createFormulaEngine(getRaw);
function pushHistory() {
  pushHistorySnapshot(history, future, cells, styles);
}
function undo() {
  const prev = history.pop();
  if (!prev) return;
  future.push({ cells: cloneMap(cells), styles: cloneMap(styles) });
  applySnapshotToMaps(prev, cells, styles);
  refreshAll();
}
function redo() {
  const next = future.pop();
  if (!next) return;
  history.push({ cells: cloneMap(cells), styles: cloneMap(styles) });
  applySnapshotToMaps(next, cells, styles);
  refreshAll();
}
function clearHighlights(className) {
  tds.forEach((td) => td.classList.remove(className));
}
function updateToolbarState() {
  const style = getStyleForRef(styles, selected);
  boldBtn.classList.toggle("active", style.bold);
  italicBtn.classList.toggle("active", style.italic);
  underlineBtn.classList.toggle("active", style.underline);
  fontSizeSel.value = String(style.fontSize);
  textColor.value = style.color;
  bgColor.value = style.bg;
  alignSel.value = style.align;
}
function updateSelectionUI() {
  clearHighlights("selected");
  clearHighlights("active");
  clearHighlights("fill-preview");
  const rect = rangeRect(selectionStart, selectionEnd);
  for (const ref of refsInRect(rect)) tds.get(ref)?.classList.add("selected");
  const activeTd = tds.get(selected);
  if (activeTd) {
    activeTd.classList.add("active");
    activeTd.appendChild(fillHandle);
  }
  cellName.textContent = selectionStart === selectionEnd ? selected : `${selectionStart}:${selectionEnd}`;
  if (editingRef !== selected) formulaInput.value = getRaw(selected);
  updateToolbarState();
}
function setSelection(start, end, active = false) {
  selectionStart = start;
  selectionEnd = end;
  if (active) selected = end;
  updateSelectionUI();
}
function refreshCell(ref) {
  const input = inputs.get(ref);
  if (!input) return;
  if (editingRef !== ref) input.value = formulaEngine.display(ref);
  const style = getStyleForRef(styles, ref);
  input.style.fontWeight = style.bold ? "700" : "400";
  input.style.fontStyle = style.italic ? "italic" : "normal";
  input.style.textDecoration = style.underline ? "underline" : "none";
  input.style.fontSize = `${style.fontSize}px`;
  input.style.color = style.color;
  input.style.background = style.bg;
  input.style.textAlign = style.align;
}
function refreshAll() {
  inputs.forEach((_, ref) => refreshCell(ref));
  updateSelectionUI();
}
function commitCell(ref, value) {
  const prev = getRaw(ref);
  if (prev === value) {
    refreshCell(ref);
    return;
  }
  pushHistory();
  if (value) cells[ref] = value;
  else delete cells[ref];
  refreshAll();
}
function applyStyleToSelection(patch) {
  pushHistory();
  const rect = rangeRect(selectionStart, selectionEnd);
  for (const ref of refsInRect(rect)) {
    const merged = { ...getStyleForRef(styles, ref), ...patch };
    const normalized = normalizeStyle(merged);
    if (normalized) styles[ref] = normalized;
    else delete styles[ref];
  }
  refreshAll();
}
function toggleStyle(styleKey) {
  const current = getStyleForRef(styles, selected);
  applyStyleToSelection({ [styleKey]: !current[styleKey] });
}
function clearSelectionValues() {
  pushHistory();
  const rect = rangeRect(selectionStart, selectionEnd);
  for (const ref of refsInRect(rect)) delete cells[ref];
  refreshAll();
}
function updateFillPreview() {
  clearHighlights("fill-preview");
  if (!isFillDragging || !fillSource || !fillTarget) return;
  const dest = computeFillDestination(fillSource, fillTarget);
  if (!dest) return;
  for (const ref of refsInRect(dest)) tds.get(ref)?.classList.add("fill-preview");
}
function applyFill() {
  if (!fillSource || !fillTarget) return;
  const dest = computeFillDestination(fillSource, fillTarget);
  if (!dest) return;
  pushHistory();
  for (const ref of refsInRect(dest)) {
    const src = sourceForDestination(fillSource, ref);
    const pDest = parseRef(ref);
    const pSrc = parseRef(src);
    const shifted = shiftFormula(getRaw(src), pDest.r - pSrc.r, pDest.c - pSrc.c);
    if (shifted) cells[ref] = shifted;
    else delete cells[ref];
    const srcStyle = styles[src];
    if (srcStyle) styles[ref] = { ...srcStyle };
    else delete styles[ref];
  }
  if (dest.r2 > fillSource.r2) {
    selectionStart = key(fillSource.c1, fillSource.r1);
    selectionEnd = key(fillSource.c2, dest.r2);
  } else if (dest.r1 < fillSource.r1) {
    selectionStart = key(fillSource.c1, dest.r1);
    selectionEnd = key(fillSource.c2, fillSource.r2);
  } else if (dest.c2 > fillSource.c2) {
    selectionStart = key(fillSource.c1, fillSource.r1);
    selectionEnd = key(dest.c2, fillSource.r2);
  } else if (dest.c1 < fillSource.c1) {
    selectionStart = key(dest.c1, fillSource.r1);
    selectionEnd = key(fillSource.c2, fillSource.r2);
  }
  refreshAll();
}
function exportCsv() {
  let maxRow = 1;
  let maxCol = 1;
  for (const ref of Object.keys(cells)) {
    const parsed = parseRef(ref);
    if (!parsed) continue;
    if (!cells[ref]) continue;
    maxRow = Math.max(maxRow, parsed.r);
    maxCol = Math.max(maxCol, parsed.c);
  }
  const lines = [];
  for (let r = 1; r <= maxRow; r++) {
    const row = [];
    for (let c = 1; c <= maxCol; c++) row.push(csvEscape(getRaw(key(c, r))));
    lines.push(row.join(","));
  }
  const csv = lines.join("\n");
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "sheet.csv";
  a.click();
  URL.revokeObjectURL(url);
}
function buildSheet() {
  const table = document.createElement("table");
  const thead = document.createElement("thead");
  const hr = document.createElement("tr");
  const corner = document.createElement("th");
  corner.className = "corner";
  hr.appendChild(corner);
  for (let c = 1; c <= COLS; c++) {
    const th = document.createElement("th");
    th.textContent = colLabel(c);
    hr.appendChild(th);
  }
  thead.appendChild(hr);
  table.appendChild(thead);
  const tbody = document.createElement("tbody");
  for (let r = 1; r <= ROWS; r++) {
    const tr = document.createElement("tr");
    const rowHead = document.createElement("th");
    rowHead.className = "rowHead";
    rowHead.textContent = String(r);
    tr.appendChild(rowHead);
    for (let c = 1; c <= COLS; c++) {
      const ref = key(c, r);
      const td = document.createElement("td");
      td.dataset.ref = ref;
      const input = document.createElement("input");
      input.spellcheck = false;
      td.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        if (e.target.classList.contains("fill-handle")) return;
        isSelecting = true;
        if (e.shiftKey) setSelection(selectionStart, ref, true);
        else {
          selected = ref;
          setSelection(ref, ref, true);
        }
        input.focus();
      });
      td.addEventListener("mouseenter", () => {
        if (isSelecting) setSelection(selectionStart, ref, true);
        if (isFillDragging) {
          fillTarget = ref;
          updateFillPreview();
        }
      });
      input.addEventListener("focus", () => {
        editingRef = ref;
        selected = ref;
        if (!isSelecting) setSelection(ref, ref, true);
        input.value = getRaw(ref);
      });
      input.addEventListener("blur", () => {
        const value = input.value;
        editingRef = null;
        commitCell(ref, value);
      });
      input.addEventListener("keydown", (e) => {
        const parsed = parseRef(ref);
        if (e.key === "Enter") {
          e.preventDefault();
          input.blur();
          const next = key(parsed.c, Math.min(ROWS, parsed.r + 1));
          inputs.get(next)?.focus();
        } else if (e.key === "Tab") {
          e.preventDefault();
          input.blur();
          const next = key(Math.min(COLS, parsed.c + 1), parsed.r);
          inputs.get(next)?.focus();
        } else if (e.key === "Escape") {
          e.preventDefault();
          input.value = formulaEngine.display(ref);
          input.blur();
        }
      });
      td.appendChild(input);
      tr.appendChild(td);
      inputs.set(ref, input);
      tds.set(ref, td);
    }
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  sheetEl.innerHTML = "";
  sheetEl.appendChild(table);
  fillHandle.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    isFillDragging = true;
    fillSource = rangeRect(selectionStart, selectionEnd);
    fillTarget = selected;
    updateFillPreview();
  });
}
formulaInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    commitCell(selected, formulaInput.value);
    inputs.get(selected)?.focus();
  }
});
boldBtn.addEventListener("click", () => toggleStyle("bold"));
italicBtn.addEventListener("click", () => toggleStyle("italic"));
underlineBtn.addEventListener("click", () => toggleStyle("underline"));
fontSizeSel.addEventListener("change", () => applyStyleToSelection({ fontSize: Number(fontSizeSel.value) }));
textColor.addEventListener("change", () => applyStyleToSelection({ color: textColor.value }));
bgColor.addEventListener("change", () => applyStyleToSelection({ bg: bgColor.value }));
alignSel.addEventListener("change", () => applyStyleToSelection({ align: alignSel.value }));
undoBtn.addEventListener("click", undo);
redoBtn.addEventListener("click", redo);
saveBtn.addEventListener("click", async () => {
  const json = JSON.stringify({ cells, styles }, null, 2);
  await navigator.clipboard.writeText(json);
  saveBtn.textContent = "Copied";
  setTimeout(() => saveBtn.textContent = "Save", 1e3);
});
loadBtn.addEventListener("click", () => {
  const text = prompt("Paste JSON: { cells: {...}, styles: {...} } (legacy cell map also supported)");
  if (!text) return;
  try {
    const parsed = JSON.parse(text);
    pushHistory();
    for (const k of Object.keys(cells)) delete cells[k];
    for (const k of Object.keys(styles)) delete styles[k];
    if (parsed && typeof parsed === "object" && parsed.cells && typeof parsed.cells === "object") {
      for (const [k, v] of Object.entries(parsed.cells)) {
        if (typeof v === "string") cells[k.toUpperCase()] = v;
      }
      if (parsed.styles && typeof parsed.styles === "object") {
        for (const [k, v] of Object.entries(parsed.styles)) {
          if (!v || typeof v !== "object") continue;
          const normalized = normalizeStyle(v);
          if (normalized) styles[k.toUpperCase()] = normalized;
        }
      }
    } else {
      for (const [k, v] of Object.entries(parsed)) {
        if (typeof v === "string") cells[k.toUpperCase()] = v;
      }
    }
    refreshAll();
  } catch {
    alert("Invalid JSON");
  }
});
csvBtn.addEventListener("click", () => {
  exportCsv();
  csvBtn.textContent = "Done";
  setTimeout(() => csvBtn.textContent = "CSV", 1e3);
});
document.addEventListener("mouseup", () => {
  isSelecting = false;
  if (isFillDragging) {
    applyFill();
    isFillDragging = false;
    fillSource = null;
    fillTarget = null;
    clearHighlights("fill-preview");
  }
});
document.addEventListener("keydown", (e) => {
  const target = e.target;
  const isFormula = target === formulaInput;
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
    e.preventDefault();
    if (e.shiftKey) redo();
    else undo();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
    e.preventDefault();
    redo();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "b") {
    e.preventDefault();
    toggleStyle("bold");
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "i") {
    e.preventDefault();
    toggleStyle("italic");
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "u") {
    e.preventDefault();
    toggleStyle("underline");
    return;
  }
  if (e.key === "Delete" && !isFormula) {
    clearSelectionValues();
  }
});
buildSheet();
refreshAll();

  </script>
</body>
</html>