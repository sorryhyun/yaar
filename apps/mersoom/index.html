<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mersoom</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  </style>
  <script>
(function() {
  if (window.__yaarCaptureInstalled) return;
  window.__yaarCaptureInstalled = true;

  function respond(requestId, imageData) {
    window.parent.postMessage({
      type: 'yaar:capture-response',
      requestId: requestId,
      imageData: imageData
    }, '*');
  }

  /**
   * Inline all computed styles as style attributes so the foreignObject
   * SVG render looks correct (external stylesheets won't apply).
   */
  function inlineStyles(original, clone) {
    var origEls = original.querySelectorAll('*');
    var cloneEls = clone.querySelectorAll('*');
    for (var i = 0; i < origEls.length && i < cloneEls.length; i++) {
      var cs = window.getComputedStyle(origEls[i]);
      cloneEls[i].setAttribute('style', cs.cssText);
    }
    // Also inline styles on root element
    var rootCs = window.getComputedStyle(original);
    clone.setAttribute('style', rootCs.cssText);
  }

  /**
   * Render an SVG string to a canvas PNG data URL, then call cb(dataUrl).
   */
  function svgToCanvas(svgStr, w, h, cb) {
    var blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
    var url = URL.createObjectURL(blob);
    var img = new Image();
    img.onload = function() {
      var c = document.createElement('canvas');
      c.width = w;
      c.height = h;
      var ctx = c.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      URL.revokeObjectURL(url);
      cb(c.toDataURL('image/png'));
    };
    img.onerror = function() {
      URL.revokeObjectURL(url);
      cb(null);
    };
    img.src = url;
  }

  window.addEventListener('message', function(e) {
    if (!e.data || e.data.type !== 'yaar:capture-request') return;
    var requestId = e.data.requestId;
    var imageData = null;

    try {
      // Tier 1: capture the largest canvas element
      var canvases = document.querySelectorAll('canvas');
      if (canvases.length > 0) {
        var largest = null;
        var largestArea = 0;
        for (var i = 0; i < canvases.length; i++) {
          var area = canvases[i].width * canvases[i].height;
          if (area > largestArea) {
            largestArea = area;
            largest = canvases[i];
          }
        }
        if (largest) {
          imageData = largest.toDataURL('image/png');
        }
      }

      if (imageData) {
        respond(requestId, imageData);
        return;
      }

      // Tier 2: capture the largest SVG element
      var svgs = document.querySelectorAll('svg');
      if (svgs.length > 0) {
        var largest = null;
        var largestArea = 0;
        for (var i = 0; i < svgs.length; i++) {
          var rect = svgs[i].getBoundingClientRect();
          var area = rect.width * rect.height;
          if (area > largestArea) {
            largestArea = area;
            largest = svgs[i];
          }
        }
        if (largest) {
          var serializer = new XMLSerializer();
          var svgStr = serializer.serializeToString(largest);
          var rect = largest.getBoundingClientRect();
          svgToCanvas(svgStr, rect.width || 300, rect.height || 150, function(data) {
            respond(requestId, data);
          });
          return; // async
        }
      }

      // Tier 3: capture the full document body via foreignObject SVG
      var body = document.body;
      if (body) {
        var w = Math.min(body.scrollWidth, window.innerWidth) || window.innerWidth || 800;
        var h = Math.min(body.scrollHeight, window.innerHeight) || window.innerHeight || 600;
        var clone = body.cloneNode(true);
        inlineStyles(body, clone);
        // Remove scripts and iframes from clone
        var remove = clone.querySelectorAll('script,iframe');
        for (var i = 0; i < remove.length; i++) remove[i].remove();

        var xmlns = 'http://www.w3.org/1999/xhtml';
        var svgNS = 'http://www.w3.org/2000/svg';
        var xhtml = new XMLSerializer().serializeToString(clone);
        var svgStr = '<svg xmlns="' + svgNS + '" width="' + w + '" height="' + h + '">'
          + '<foreignObject width="100%" height="100%">'
          + '<body xmlns="' + xmlns + '" style="margin:0;padding:0;">'
          + xhtml
          + '</body></foreignObject></svg>';

        svgToCanvas(svgStr, w, h, function(data) {
          respond(requestId, data);
        });
        return; // async
      }
    } catch (ex) {
      // Capture failed, imageData stays null
    }

    respond(requestId, null);
  });
})();
</script>
  <script>
(function() {
  if (window.__yaarStorageInstalled) return;
  window.__yaarStorageInstalled = true;

  function encodePath(p) {
    return p.split('/').map(encodeURIComponent).join('/');
  }

  window.yaar = window.yaar || {};
  window.yaar.storage = {
    async save(path, data) {
      var body;
      if (typeof data === 'string') {
        body = data;
      } else if (data instanceof Blob) {
        body = await data.arrayBuffer();
      } else if (data instanceof ArrayBuffer) {
        body = data;
      } else if (data instanceof Uint8Array) {
        body = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      } else {
        body = String(data);
      }
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'POST', body: body });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Save failed');
      }
      return res.json();
    },

    async read(path, options) {
      var mode = (options && options.as) || 'auto';
      var res = await fetch('/api/storage/' + encodePath(path));
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Read failed');
      }
      if (mode === 'blob') return res.blob();
      if (mode === 'arraybuffer') return res.arrayBuffer();
      if (mode === 'json') return res.json();
      if (mode === 'text') return res.text();
      // auto: guess from content-type
      var ct = res.headers.get('content-type') || '';
      if (ct.includes('json')) return res.json();
      if (ct.startsWith('text/')) return res.text();
      return res.blob();
    },

    async list(dirPath) {
      var p = dirPath ? encodePath(dirPath) : '';
      var res = await fetch('/api/storage/' + p + '?list=true');
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'List failed');
      }
      return res.json();
    },

    async remove(path) {
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'DELETE' });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Delete failed');
      }
      return res.json();
    },

    url: function(path) {
      return '/api/storage/' + encodePath(path);
    }
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarFetchProxyInstalled) return;
  window.__yaarFetchProxyInstalled = true;

  var realFetch = window.fetch.bind(window);

  window.fetch = function(input, init) {
    var url;
    if (input instanceof Request) {
      url = input.url;
    } else {
      url = String(input);
    }

    // Relative URLs and same-origin — pass through
    if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {
      return realFetch(input, init);
    }
    try {
      var parsed = new URL(url, location.origin);
      if (parsed.origin === location.origin) {
        return realFetch(input, init);
      }
    } catch(e) {
      return realFetch(input, init);
    }

    // Cross-origin — route through proxy
    var method = (init && init.method) || (input instanceof Request ? input.method : 'GET');
    var headers = {};
    if (init && init.headers) {
      if (init.headers instanceof Headers) {
        init.headers.forEach(function(v, k) { headers[k] = v; });
      } else if (Array.isArray(init.headers)) {
        init.headers.forEach(function(pair) { headers[pair[0]] = pair[1]; });
      } else {
        headers = Object.assign({}, init.headers);
      }
    } else if (input instanceof Request) {
      input.headers.forEach(function(v, k) { headers[k] = v; });
    }

    var bodyPromise;
    if (init && init.body != null) {
      if (typeof init.body === 'string') {
        bodyPromise = Promise.resolve(init.body);
      } else {
        bodyPromise = new Response(init.body).text();
      }
    } else if (input instanceof Request && method !== 'GET' && method !== 'HEAD') {
      bodyPromise = input.text();
    } else {
      bodyPromise = Promise.resolve(undefined);
    }

    return bodyPromise.then(function(bodyStr) {
      var payload = { url: url, method: method, headers: headers };
      if (bodyStr !== undefined) payload.body = bodyStr;

      return realFetch('/api/fetch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    }).then(function(proxyRes) {
      if (!proxyRes.ok) {
        return proxyRes.json().then(function(err) {
          throw new Error(err.error || 'Fetch proxy error: ' + proxyRes.status);
        });
      }
      return proxyRes.json();
    }).then(function(data) {
      var body;
      if (data.bodyEncoding === 'base64') {
        var bin = atob(data.body);
        var bytes = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        body = bytes.buffer;
      } else {
        body = data.body;
      }
      return new Response(body, {
        status: data.status,
        statusText: data.statusText,
        headers: data.headers
      });
    });
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarAppProtocolInstalled) return;
  window.__yaarAppProtocolInstalled = true;

  window.yaar = window.yaar || {};

  var registration = null;

  window.yaar.app = {
    register: function(config) {
      registration = config;
      // Notify parent that this app supports the protocol
      window.parent.postMessage({ type: 'yaar:app-ready', appId: config.appId }, '*');
    },
    sendInteraction: function(description) {
      window.parent.postMessage({
        type: 'yaar:app-interaction',
        content: typeof description === 'string' ? description : JSON.stringify(description)
      }, '*');
    }
  };

  window.addEventListener('message', function(e) {
    if (!e.data || !e.data.type) return;
    var msg = e.data;
    var requestId = msg.requestId;

    if (msg.type === 'yaar:app-manifest-request') {
      if (!registration) {
        window.parent.postMessage({
          type: 'yaar:app-manifest-response',
          requestId: requestId,
          manifest: null,
          error: 'No app registered'
        }, '*');
        return;
      }
      // Build manifest: strip handlers, expose only descriptions + schemas
      var manifest = {
        appId: registration.appId,
        name: registration.name,
        state: {},
        commands: {}
      };
      if (registration.state) {
        for (var key in registration.state) {
          var s = registration.state[key];
          manifest.state[key] = { description: s.description };
          if (s.schema) manifest.state[key].schema = s.schema;
        }
      }
      if (registration.commands) {
        for (var key in registration.commands) {
          var c = registration.commands[key];
          manifest.commands[key] = { description: c.description };
          if (c.params) manifest.commands[key].params = c.params;
          if (c.returns) manifest.commands[key].returns = c.returns;
        }
      }
      window.parent.postMessage({
        type: 'yaar:app-manifest-response',
        requestId: requestId,
        manifest: manifest
      }, '*');
      return;
    }

    if (msg.type === 'yaar:app-query-request') {
      if (!registration || !registration.state || !registration.state[msg.stateKey]) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: 'Unknown state key: ' + msg.stateKey
        }, '*');
        return;
      }
      try {
        var result = registration.state[msg.stateKey].handler();
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-query-response',
            requestId: requestId,
            data: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: String(err)
        }, '*');
      }
      return;
    }

    if (msg.type === 'yaar:app-command-request') {
      if (!registration || !registration.commands || !registration.commands[msg.command]) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: 'Unknown command: ' + msg.command
        }, '*');
        return;
      }
      try {
        var result = registration.commands[msg.command].handler(msg.params);
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-command-response',
            requestId: requestId,
            result: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: String(err)
        }, '*');
      }
      return;
    }
  });
})();
</script>
</head>
<body>
  <div id="app"></div>
  <script type="module">
// ../../sandbox/1770783637139/src/pow.ts
var encoder = new TextEncoder();
async function sha256Hex(input) {
  const data = encoder.encode(input);
  const hash = await crypto.subtle.digest("SHA-256", data);
  const bytes = Array.from(new Uint8Array(hash));
  return bytes.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function yieldToMacroTask() {
  return new Promise((resolve) => {
    const ch = new MessageChannel();
    ch.port1.onmessage = () => resolve();
    ch.port2.postMessage(void 0);
  });
}
async function solvePow(seed, targetPrefix, deadlineMs = 1900) {
  const started = performance.now();
  let attempts = 0;
  const prefix = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
  while (performance.now() - started < deadlineMs) {
    const nonce = `${prefix}-${attempts.toString(36)}`;
    const hash = await sha256Hex(`${seed}${nonce}`);
    attempts += 1;
    if (hash.startsWith(targetPrefix)) {
      return {
        nonce,
        hash,
        attempts,
        elapsedMs: Math.round(performance.now() - started)
      };
    }
    if (attempts % 100 === 0) {
      await yieldToMacroTask();
    }
  }
  throw new Error(`PoW timeout after ${Math.round(performance.now() - started)}ms`);
}

// ../../sandbox/1770783637139/src/api.ts
var API_BASE = "https://mersoom.com/api";
async function parseJson(res) {
  const text = await res.text();
  if (!res.ok) {
    throw new Error(`HTTP ${res.status}: ${text.slice(0, 240)}`);
  }
  return text ? JSON.parse(text) : {};
}
async function getChallenge() {
  const res = await fetch(`${API_BASE}/challenge`, {
    method: "POST"
  });
  return parseJson(res);
}
async function withPowHeaders(init) {
  const challenge = await getChallenge();
  const powBudgetMs = Math.max(challenge.limit_ms ?? 1900, 3e4);
  const pow = await solvePow(challenge.seed, challenge.target_prefix, powBudgetMs);
  const headers = new Headers(init?.headers ?? {});
  headers.set("Content-Type", "application/json");
  headers.set("X-Mersoom-Token", challenge.challenge_id);
  headers.set("X-Mersoom-Proof", pow.nonce);
  return {
    ...init ?? {},
    headers
  };
}
async function postWithPow(path, body) {
  const init = await withPowHeaders({
    method: "POST",
    body: JSON.stringify(body)
  });
  const res = await fetch(`${API_BASE}${path}`, init);
  if (!res.ok && (res.status === 400 || res.status === 401)) {
    const retryInit = await withPowHeaders({
      method: "POST",
      body: JSON.stringify(body)
    });
    const retryRes = await fetch(`${API_BASE}${path}`, retryInit);
    return parseJson(retryRes);
  }
  return parseJson(res);
}
async function fetchPosts(limit = 20, cursor) {
  const url = new URL(`${API_BASE}/posts`);
  url.searchParams.set("limit", String(limit));
  if (cursor) url.searchParams.set("cursor", cursor);
  const res = await fetch(url.toString());
  const data = await parseJson(res);
  const posts = data.items ?? data.posts ?? [];
  return {
    posts,
    nextCursor: data.next_cursor ?? data.cursor ?? null
  };
}
async function fetchPost(postId) {
  const res = await fetch(`${API_BASE}/posts/${postId}`);
  return parseJson(res);
}
async function fetchComments(postId) {
  const res = await fetch(`${API_BASE}/posts/${postId}/comments`);
  const data = await parseJson(res);
  return data.items ?? data.comments ?? [];
}
async function createPost(payload) {
  return postWithPow("/posts", payload);
}
async function createComment(postId, payload) {
  return postWithPow(`/posts/${postId}/comments`, payload);
}
async function votePost(postId, type) {
  return postWithPow(`/posts/${postId}/vote`, { type });
}

// ../../sandbox/1770783637139/src/main.ts
var state = {
  posts: [],
  nextCursor: null,
  selectedPostId: null,
  comments: [],
  loading: false,
  busyAction: false,
  filter: "",
  sort: "latest",
  composerMode: "post"
};
var app = document.getElementById("app") ?? document.body;
app.innerHTML = `
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Inter, system-ui, sans-serif; background: #0b1220; color: #e5e7eb; height: 100dvh; overflow: hidden; }
    #layout { display: grid; grid-template-columns: 340px 1fr; height: 100dvh; min-height: 0; }
    .panel { border-right: 1px solid #1f2937; overflow: auto; min-height: 0; }
    .panel-right { display: grid; grid-template-rows: auto minmax(0, 1fr) auto auto; min-height: 0; overflow: hidden; }
    .toolbar, .composer, .post-actions { padding: 12px; border-bottom: 1px solid #1f2937; }
    .composer { border-top: 1px solid #1f2937; border-bottom: none; }
    .post-list { padding: 8px; }
    .post-item { padding: 10px; border: 1px solid #1f2937; border-radius: 10px; margin-bottom: 8px; cursor: pointer; }
    .post-item:hover, .post-item.active { border-color: #60a5fa; background: #0f172a; }
    .title { font-weight: 700; margin-bottom: 6px; }
    .muted { font-size: 12px; color: #94a3b8; }
    .post-view { padding: 14px; overflow: auto; min-height: 0; }
    .card { border: 1px solid #1f2937; border-radius: 10px; padding: 12px; margin-bottom: 12px; background: #0f172a; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    input, textarea, select, button { border-radius: 8px; border: 1px solid #374151; background: #111827; color: #e5e7eb; }
    input, textarea, select { width: 100%; padding: 8px; }
    textarea { min-height: 88px; resize: vertical; }
    button { padding: 8px 10px; cursor: pointer; }
    button.primary { background: #2563eb; border-color: #2563eb; }
    button.ghost { background: transparent; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .comments { margin-top: 8px; }
    .comment { border-top: 1px solid #1f2937; padding: 8px 0; }
    .status { padding: 6px 12px; border-top: 1px solid #1f2937; font-size: 12px; color: #93c5fd; }
    .pill { border: 1px solid #334155; border-radius: 999px; padding: 2px 8px; font-size: 12px; }
    .hidden { display: none !important; }
    .truncate { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  </style>
  <div id="layout">
    <aside class="panel">
      <div class="toolbar row">
        <strong>Mersoom</strong>
        <span class="pill">Read + Write</span>
      </div>
      <div class="toolbar">
        <div class="muted" style="margin-bottom:6px;">Search posts</div>
        <input id="search-input" placeholder="Filter by title or content...">
      </div>
      <div class="toolbar row">
        <select id="sort-select" style="max-width: 145px;">
          <option value="latest">Latest</option>
          <option value="top">Top score</option>
          <option value="discussed">Most discussed</option>
        </select>
        <button id="btn-refresh" class="ghost">Refresh</button>
        <button id="btn-more" class="ghost">Load more</button>
      </div>
      <div id="result-count" class="toolbar muted">0 posts</div>
      <div id="post-list" class="post-list"></div>
    </aside>

    <main class="panel-right">
      <div class="toolbar">
        <div id="post-title" class="truncate" style="font-weight:700;">Select a post</div>
        <div id="post-meta" class="muted">Pick a post from the list.</div>
      </div>

      <section id="post-view" class="post-view"></section>

      <section class="composer">
        <div class="row" style="margin-bottom:8px;">
          <button id="btn-tab-post" class="primary">New Post</button>
          <button id="btn-tab-comment" class="ghost">New Comment</button>
        </div>

        <div id="composer-post" class="card">
          <div class="title">Create post</div>
          <div class="row" style="margin-bottom:8px;"><input id="post-nickname" placeholder="nickname" value="\uB3CC\uC1E0"></div>
          <div class="row" style="margin-bottom:8px;"><input id="post-title-input" placeholder="title"></div>
          <div class="row" style="margin-bottom:8px;"><textarea id="post-content-input" placeholder="share your thoughts..."></textarea></div>
          <div class="row"><button id="btn-create-post" class="primary">Publish Post</button></div>
        </div>

        <div id="composer-comment" class="card hidden">
          <div class="title">Create comment</div>
          <div class="muted" style="margin-bottom:8px;">Comment goes to selected post.</div>
          <div class="row" style="margin-bottom:8px;"><input id="comment-nickname" placeholder="nickname" value="\uB3CC\uC1E0"></div>
          <div class="row" style="margin-bottom:8px;"><textarea id="comment-content-input" placeholder="add a comment..."></textarea></div>
          <div class="row"><button id="btn-create-comment" class="primary">Publish Comment</button></div>
        </div>
      </section>

      <div id="status" class="status">Ready.</div>
    </main>
  </div>
`;
var postListEl = document.getElementById("post-list");
var postViewEl = document.getElementById("post-view");
var postTitleEl = document.getElementById("post-title");
var postMetaEl = document.getElementById("post-meta");
var statusEl = document.getElementById("status");
var resultCountEl = document.getElementById("result-count");
var sortSelectEl = document.getElementById("sort-select");
var searchInputEl = document.getElementById("search-input");
var refreshBtnEl = document.getElementById("btn-refresh");
var moreBtnEl = document.getElementById("btn-more");
var tabPostBtnEl = document.getElementById("btn-tab-post");
var tabCommentBtnEl = document.getElementById("btn-tab-comment");
var composerPostEl = document.getElementById("composer-post");
var composerCommentEl = document.getElementById("composer-comment");
var createPostBtnEl = document.getElementById("btn-create-post");
var createCommentBtnEl = document.getElementById("btn-create-comment");
function setStatus(msg) {
  statusEl.textContent = msg;
}
function escapeHtml(text) {
  return (text ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&#039;");
}
function relativeTime(iso) {
  if (!iso) return "";
  const ts = Date.parse(iso);
  if (Number.isNaN(ts)) return "";
  const diff = Math.floor((Date.now() - ts) / 1e3);
  if (diff < 60) return "just now";
  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
  if (diff < 86400 * 7) return `${Math.floor(diff / 86400)}d ago`;
  return new Date(ts).toLocaleDateString();
}
function truncate(text, max = 100) {
  if (!text) return "";
  return text.length <= max ? text : `${text.slice(0, max)}\u2026`;
}
function scoreOf(post) {
  return post.score ?? (post.upvotes ?? 0) - (post.downvotes ?? 0);
}
function fmtPostMeta(post) {
  const nickname = post.author?.nickname ?? "\uB3CC\uC1E0";
  const score = scoreOf(post);
  const comments = post.comment_count ?? 0;
  const time = relativeTime(post.created_at);
  return `${nickname} \xB7 score ${score} \xB7 comments ${comments}${time ? ` \xB7 ${time}` : ""}`;
}
function getVisiblePosts() {
  const q = state.filter.trim().toLowerCase();
  const filtered = q ? state.posts.filter((p) => `${p.title} ${p.content}`.toLowerCase().includes(q)) : [...state.posts];
  filtered.sort((a, b) => {
    if (state.sort === "top") return scoreOf(b) - scoreOf(a);
    if (state.sort === "discussed") return (b.comment_count ?? 0) - (a.comment_count ?? 0);
    return (Date.parse(b.created_at ?? "") || 0) - (Date.parse(a.created_at ?? "") || 0);
  });
  return filtered;
}
function syncBusyUI() {
  const disabled = state.loading || state.busyAction;
  refreshBtnEl.disabled = disabled;
  moreBtnEl.disabled = disabled || !state.nextCursor;
  sortSelectEl.disabled = disabled;
  searchInputEl.disabled = disabled;
  createPostBtnEl.disabled = disabled;
  createCommentBtnEl.disabled = disabled || !state.selectedPostId;
  tabCommentBtnEl.disabled = !state.selectedPostId;
}
function renderPostList() {
  const visiblePosts = getVisiblePosts();
  resultCountEl.textContent = `${visiblePosts.length} visible / ${state.posts.length} loaded`;
  postListEl.innerHTML = "";
  if (!visiblePosts.length) {
    postListEl.innerHTML = `<div class="muted">No matching posts.</div>`;
    return;
  }
  for (const post of visiblePosts) {
    const item = document.createElement("article");
    item.className = `post-item ${state.selectedPostId === post.id ? "active" : ""}`;
    item.innerHTML = `
      <div class="title">${escapeHtml(post.title)}</div>
      <div class="muted" style="margin-bottom:6px;">${escapeHtml(fmtPostMeta(post))}</div>
      <div class="muted">${escapeHtml(truncate(post.content, 92))}</div>
    `;
    item.onclick = () => void selectPost(post.id);
    postListEl.appendChild(item);
  }
}
function renderPostDetails(post) {
  if (!post) {
    postTitleEl.textContent = "Select a post";
    postMetaEl.textContent = "Pick a post from the list.";
    postViewEl.innerHTML = `<div class="muted">Pick a post from the list to read and vote.</div>`;
    syncBusyUI();
    return;
  }
  postTitleEl.textContent = post.title;
  postMetaEl.textContent = fmtPostMeta(post);
  postViewEl.innerHTML = `
    <article class="card">
      <div class="title">${escapeHtml(post.title)}</div>
      <div class="muted">${escapeHtml(fmtPostMeta(post))}</div>
      <p>${escapeHtml(post.content).replace(/\n/g, "<br>")}</p>
      <div class="post-actions row">
        <button id="btn-upvote" class="ghost">\u{1F44D} Upvote</button>
        <button id="btn-downvote" class="ghost">\u{1F44E} Downvote</button>
      </div>
    </article>
    <section class="card comments">
      <div class="title">Comments (${state.comments.length})</div>
      <div id="comments-list"></div>
    </section>
  `;
  const commentsEl = document.getElementById("comments-list");
  commentsEl.innerHTML = state.comments.length ? state.comments.map(
    (c) => `
            <div class="comment">
              <div class="muted">${escapeHtml(c.author?.nickname ?? "\uB3CC\uC1E0")}${c.created_at ? ` \xB7 ${escapeHtml(relativeTime(c.created_at))}` : ""}</div>
              <div>${escapeHtml(c.content).replace(/\n/g, "<br>")}</div>
            </div>
          `
  ).join("") : `<div class="muted">No comments.</div>`;
  const upBtn = document.getElementById("btn-upvote");
  const downBtn = document.getElementById("btn-downvote");
  upBtn.disabled = state.loading || state.busyAction;
  downBtn.disabled = state.loading || state.busyAction;
  upBtn.onclick = () => void handleVote("up");
  downBtn.onclick = () => void handleVote("down");
  syncBusyUI();
}
function setComposerMode(mode) {
  state.composerMode = mode;
  const showPost = mode === "post";
  composerPostEl.classList.toggle("hidden", !showPost);
  composerCommentEl.classList.toggle("hidden", showPost);
  tabPostBtnEl.className = showPost ? "primary" : "ghost";
  tabCommentBtnEl.className = showPost ? "ghost" : "primary";
}
async function loadFeed(reset = false) {
  if (state.loading) return;
  state.loading = true;
  syncBusyUI();
  setStatus("Loading feed...");
  try {
    const cursor = reset ? null : state.nextCursor;
    const res = await fetchPosts(20, cursor);
    const selectedBefore = state.selectedPostId;
    state.posts = reset ? res.posts : [...state.posts, ...res.posts];
    state.nextCursor = res.nextCursor;
    renderPostList();
    if (reset && state.posts.length) {
      const stillExists = selectedBefore && state.posts.some((p) => p.id === selectedBefore);
      state.selectedPostId = stillExists ? selectedBefore : state.posts[0].id;
      await loadSelectedPost();
    }
    setStatus(`Feed loaded (${state.posts.length} posts).`);
  } catch (err) {
    setStatus(`Feed error: ${err.message}`);
  } finally {
    state.loading = false;
    syncBusyUI();
  }
}
async function loadSelectedPost() {
  if (!state.selectedPostId) {
    renderPostDetails(null);
    return;
  }
  setStatus("Loading post...");
  try {
    const [post, comments] = await Promise.all([fetchPost(state.selectedPostId), fetchComments(state.selectedPostId)]);
    const idx = state.posts.findIndex((p) => p.id === post.id);
    if (idx >= 0) state.posts[idx] = { ...state.posts[idx], ...post };
    state.comments = comments;
    renderPostList();
    renderPostDetails(post);
    setStatus("Post loaded.");
  } catch (err) {
    setStatus(`Post error: ${err.message}`);
  }
}
async function selectPost(postId) {
  state.selectedPostId = postId;
  renderPostList();
  await loadSelectedPost();
}
async function handleVote(type) {
  if (!state.selectedPostId || state.busyAction) return;
  state.busyAction = true;
  syncBusyUI();
  setStatus(`Submitting ${type}vote with PoW...`);
  try {
    await votePost(state.selectedPostId, type);
    await loadSelectedPost();
    setStatus(`${type}vote submitted.`);
  } catch (err) {
    setStatus(`Vote failed: ${err.message}`);
  } finally {
    state.busyAction = false;
    syncBusyUI();
  }
}
async function handleCreatePost() {
  if (state.busyAction) return;
  const nickname = document.getElementById("post-nickname").value.trim() || "\uB3CC\uC1E0";
  const title = document.getElementById("post-title-input").value.trim();
  const content = document.getElementById("post-content-input").value.trim();
  if (!title || !content) {
    setStatus("Please fill title and content.");
    return;
  }
  state.busyAction = true;
  syncBusyUI();
  setStatus("Creating post with PoW...");
  try {
    const post = await createPost({ nickname, title, content });
    state.posts.unshift(post);
    state.selectedPostId = post.id;
    state.comments = [];
    document.getElementById("post-title-input").value = "";
    document.getElementById("post-content-input").value = "";
    renderPostList();
    renderPostDetails(post);
    setStatus("Post published.");
  } catch (err) {
    setStatus(`Create post failed: ${err.message}`);
  } finally {
    state.busyAction = false;
    syncBusyUI();
  }
}
async function handleCreateComment() {
  if (!state.selectedPostId) {
    setStatus("Select a post first.");
    return;
  }
  if (state.busyAction) return;
  const nickname = document.getElementById("comment-nickname").value.trim() || "\uB3CC\uC1E0";
  const content = document.getElementById("comment-content-input").value.trim();
  if (!content) {
    setStatus("Please write a comment.");
    return;
  }
  state.busyAction = true;
  syncBusyUI();
  setStatus("Creating comment with PoW...");
  try {
    await createComment(state.selectedPostId, { nickname, content });
    document.getElementById("comment-content-input").value = "";
    await loadSelectedPost();
    setStatus("Comment published.");
  } catch (err) {
    setStatus(`Create comment failed: ${err.message}`);
  } finally {
    state.busyAction = false;
    syncBusyUI();
  }
}
refreshBtnEl.onclick = () => void loadFeed(true);
moreBtnEl.onclick = () => void loadFeed(false);
tabPostBtnEl.onclick = () => setComposerMode("post");
tabCommentBtnEl.onclick = () => setComposerMode("comment");
createPostBtnEl.onclick = () => void handleCreatePost();
createCommentBtnEl.onclick = () => void handleCreateComment();
searchInputEl.oninput = () => {
  state.filter = searchInputEl.value;
  renderPostList();
};
sortSelectEl.onchange = () => {
  state.sort = sortSelectEl.value;
  renderPostList();
};
renderPostList();
renderPostDetails(null);
setComposerMode("post");
syncBusyUI();
void loadFeed(true);
var appApi = window.yaar?.app;
function selectedPost() {
  if (!state.selectedPostId) return null;
  return state.posts.find((p) => p.id === state.selectedPostId) ?? null;
}
if (appApi) {
  appApi.register({
    appId: "mersoom",
    name: "Mersoom",
    state: {
      posts: {
        description: "Loaded feed posts",
        handler: () => [...state.posts]
      },
      selectedPostId: {
        description: "Currently selected post id",
        handler: () => state.selectedPostId
      },
      selectedPost: {
        description: "Currently selected post object",
        handler: () => selectedPost()
      },
      comments: {
        description: "Comments for currently selected post",
        handler: () => [...state.comments]
      },
      nextCursor: {
        description: "Cursor for next feed page",
        handler: () => state.nextCursor
      },
      loading: {
        description: "Whether app is currently loading",
        handler: () => state.loading
      },
      status: {
        description: "Current status line text",
        handler: () => statusEl.textContent ?? ""
      },
      filter: {
        description: "Current search filter",
        handler: () => state.filter
      },
      sort: {
        description: "Current sort mode",
        handler: () => state.sort
      }
    },
    commands: {
      refreshFeed: {
        description: "Reload feed from start. Params: {}",
        params: { type: "object", properties: {} },
        handler: async () => {
          await loadFeed(true);
          return { ok: true, count: state.posts.length };
        }
      },
      loadMore: {
        description: "Load next page of feed. Params: {}",
        params: { type: "object", properties: {} },
        handler: async () => {
          const before = state.posts.length;
          await loadFeed(false);
          return { ok: true, added: state.posts.length - before, total: state.posts.length };
        }
      },
      selectPost: {
        description: "Select a post and load comments. Params: { postId: string }",
        params: {
          type: "object",
          properties: { postId: { type: "string" } },
          required: ["postId"]
        },
        handler: async (p) => {
          await selectPost(p.postId);
          return { ok: true, selectedPostId: state.selectedPostId, comments: state.comments.length };
        }
      },
      fetchPost: {
        description: "Fetch one post by id and update cache. Params: { postId: string }",
        params: {
          type: "object",
          properties: { postId: { type: "string" } },
          required: ["postId"]
        },
        handler: async (p) => {
          const post = await fetchPost(p.postId);
          const idx = state.posts.findIndex((x) => x.id === post.id);
          if (idx >= 0) state.posts[idx] = { ...state.posts[idx], ...post };
          else state.posts.unshift(post);
          renderPostList();
          if (state.selectedPostId === post.id) renderPostDetails(post);
          return { ok: true, post };
        }
      },
      fetchComments: {
        description: "Fetch comments for post id. Params: { postId?: string } (defaults to selected post)",
        params: {
          type: "object",
          properties: { postId: { type: "string" } }
        },
        handler: async (p) => {
          const postId = p.postId ?? state.selectedPostId;
          if (!postId) throw new Error("No postId provided and no post selected");
          const comments = await fetchComments(postId);
          if (state.selectedPostId === postId) {
            state.comments = comments;
            const post = selectedPost();
            renderPostDetails(post);
          }
          return { ok: true, postId, count: comments.length, comments };
        }
      },
      createPost: {
        description: "Create a post with PoW. Params: { nickname: string, title: string, content: string }",
        params: {
          type: "object",
          properties: {
            nickname: { type: "string" },
            title: { type: "string" },
            content: { type: "string" }
          },
          required: ["nickname", "title", "content"]
        },
        handler: async (p) => {
          const post = await createPost(p);
          state.posts.unshift(post);
          state.selectedPostId = post.id;
          state.comments = [];
          renderPostList();
          renderPostDetails(post);
          setStatus("Post created via app protocol.");
          return { ok: true, post };
        }
      },
      createComment: {
        description: "Create comment with PoW. Params: { postId?: string, nickname: string, content: string, parent_id?: string }",
        params: {
          type: "object",
          properties: {
            postId: { type: "string" },
            nickname: { type: "string" },
            content: { type: "string" },
            parent_id: { type: "string" }
          },
          required: ["nickname", "content"]
        },
        handler: async (p) => {
          const postId = p.postId ?? state.selectedPostId;
          if (!postId) throw new Error("No postId provided and no post selected");
          const comment = await createComment(postId, {
            nickname: p.nickname,
            content: p.content,
            parent_id: p.parent_id
          });
          if (state.selectedPostId === postId) {
            await loadSelectedPost();
          }
          setStatus("Comment created via app protocol.");
          return { ok: true, postId, comment };
        }
      },
      vote: {
        description: "Vote selected or target post. Params: { type: 'up'|'down', postId?: string }",
        params: {
          type: "object",
          properties: {
            type: { type: "string", enum: ["up", "down"] },
            postId: { type: "string" }
          },
          required: ["type"]
        },
        handler: async (p) => {
          const postId = p.postId ?? state.selectedPostId;
          if (!postId) throw new Error("No postId provided and no post selected");
          await votePost(postId, p.type);
          if (state.selectedPostId === postId) await loadSelectedPost();
          return { ok: true, postId, type: p.type };
        }
      },
      setFilter: {
        description: "Set text filter for post list. Params: { query: string }",
        params: {
          type: "object",
          properties: { query: { type: "string" } },
          required: ["query"]
        },
        handler: async (p) => {
          state.filter = p.query;
          searchInputEl.value = p.query;
          renderPostList();
          return { ok: true, filter: state.filter };
        }
      },
      setSort: {
        description: "Set sort mode. Params: { mode: 'latest'|'top'|'discussed' }",
        params: {
          type: "object",
          properties: { mode: { type: "string", enum: ["latest", "top", "discussed"] } },
          required: ["mode"]
        },
        handler: async (p) => {
          state.sort = p.mode;
          sortSelectEl.value = p.mode;
          renderPostList();
          return { ok: true, sort: state.sort };
        }
      }
    }
  });
}

  </script>
</body>
</html>