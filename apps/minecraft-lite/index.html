<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft 3D Lite</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  </style>
  <script>
(function() {
  if (window.__yaarCaptureInstalled) return;
  window.__yaarCaptureInstalled = true;

  window.addEventListener('message', function(e) {
    if (!e.data || e.data.type !== 'yaar:capture-request') return;
    var requestId = e.data.requestId;
    var imageData = null;

    try {
      // Try capturing the largest canvas element
      var canvases = document.querySelectorAll('canvas');
      if (canvases.length > 0) {
        var largest = null;
        var largestArea = 0;
        for (var i = 0; i < canvases.length; i++) {
          var area = canvases[i].width * canvases[i].height;
          if (area > largestArea) {
            largestArea = area;
            largest = canvases[i];
          }
        }
        if (largest) {
          imageData = largest.toDataURL('image/png');
        }
      }

      // Fall back to SVG capture
      if (!imageData) {
        var svgs = document.querySelectorAll('svg');
        if (svgs.length > 0) {
          var largest = null;
          var largestArea = 0;
          for (var i = 0; i < svgs.length; i++) {
            var rect = svgs[i].getBoundingClientRect();
            var area = rect.width * rect.height;
            if (area > largestArea) {
              largestArea = area;
              largest = svgs[i];
            }
          }
          if (largest) {
            var serializer = new XMLSerializer();
            var svgStr = serializer.serializeToString(largest);
            var rect = largest.getBoundingClientRect();
            var w = rect.width || 300;
            var h = rect.height || 150;
            var img = new Image();
            var blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
            var url = URL.createObjectURL(blob);
            img.onload = function() {
              var c = document.createElement('canvas');
              c.width = w;
              c.height = h;
              var ctx = c.getContext('2d');
              ctx.drawImage(img, 0, 0, w, h);
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: c.toDataURL('image/png')
              }, '*');
            };
            img.onerror = function() {
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: null
              }, '*');
            };
            img.src = url;
            return; // async path — response sent from onload/onerror
          }
        }
      }
    } catch (ex) {
      // Capture failed, imageData stays null
    }

    window.parent.postMessage({
      type: 'yaar:capture-response',
      requestId: requestId,
      imageData: imageData
    }, '*');
  });
})();
</script>
  <script>
(function() {
  if (window.__yaarStorageInstalled) return;
  window.__yaarStorageInstalled = true;

  function encodePath(p) {
    return p.split('/').map(encodeURIComponent).join('/');
  }

  window.yaar = window.yaar || {};
  window.yaar.storage = {
    async save(path, data) {
      var body;
      if (typeof data === 'string') {
        body = data;
      } else if (data instanceof Blob) {
        body = await data.arrayBuffer();
      } else if (data instanceof ArrayBuffer) {
        body = data;
      } else if (data instanceof Uint8Array) {
        body = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      } else {
        body = String(data);
      }
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'POST', body: body });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Save failed');
      }
      return res.json();
    },

    async read(path, options) {
      var mode = (options && options.as) || 'auto';
      var res = await fetch('/api/storage/' + encodePath(path));
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Read failed');
      }
      if (mode === 'blob') return res.blob();
      if (mode === 'arraybuffer') return res.arrayBuffer();
      if (mode === 'json') return res.json();
      if (mode === 'text') return res.text();
      // auto: guess from content-type
      var ct = res.headers.get('content-type') || '';
      if (ct.includes('json')) return res.json();
      if (ct.startsWith('text/')) return res.text();
      return res.blob();
    },

    async list(dirPath) {
      var p = dirPath ? encodePath(dirPath) : '';
      var res = await fetch('/api/storage/' + p + '?list=true');
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'List failed');
      }
      return res.json();
    },

    async remove(path) {
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'DELETE' });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Delete failed');
      }
      return res.json();
    },

    url: function(path) {
      return '/api/storage/' + encodePath(path);
    }
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarFetchProxyInstalled) return;
  window.__yaarFetchProxyInstalled = true;

  var realFetch = window.fetch.bind(window);

  window.fetch = function(input, init) {
    var url;
    if (input instanceof Request) {
      url = input.url;
    } else {
      url = String(input);
    }

    // Relative URLs and same-origin — pass through
    if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {
      return realFetch(input, init);
    }
    try {
      var parsed = new URL(url, location.origin);
      if (parsed.origin === location.origin) {
        return realFetch(input, init);
      }
    } catch(e) {
      return realFetch(input, init);
    }

    // Cross-origin — route through proxy
    var method = (init && init.method) || (input instanceof Request ? input.method : 'GET');
    var headers = {};
    if (init && init.headers) {
      if (init.headers instanceof Headers) {
        init.headers.forEach(function(v, k) { headers[k] = v; });
      } else if (Array.isArray(init.headers)) {
        init.headers.forEach(function(pair) { headers[pair[0]] = pair[1]; });
      } else {
        headers = Object.assign({}, init.headers);
      }
    } else if (input instanceof Request) {
      input.headers.forEach(function(v, k) { headers[k] = v; });
    }

    var bodyPromise;
    if (init && init.body != null) {
      if (typeof init.body === 'string') {
        bodyPromise = Promise.resolve(init.body);
      } else {
        bodyPromise = new Response(init.body).text();
      }
    } else if (input instanceof Request && method !== 'GET' && method !== 'HEAD') {
      bodyPromise = input.text();
    } else {
      bodyPromise = Promise.resolve(undefined);
    }

    return bodyPromise.then(function(bodyStr) {
      var payload = { url: url, method: method, headers: headers };
      if (bodyStr !== undefined) payload.body = bodyStr;

      return realFetch('/api/fetch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    }).then(function(proxyRes) {
      if (!proxyRes.ok) {
        return proxyRes.json().then(function(err) {
          throw new Error(err.error || 'Fetch proxy error: ' + proxyRes.status);
        });
      }
      return proxyRes.json();
    }).then(function(data) {
      var body;
      if (data.bodyEncoding === 'base64') {
        var bin = atob(data.body);
        var bytes = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        body = bytes.buffer;
      } else {
        body = data.body;
      }
      return new Response(body, {
        status: data.status,
        statusText: data.statusText,
        headers: data.headers
      });
    });
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarAppProtocolInstalled) return;
  window.__yaarAppProtocolInstalled = true;

  window.yaar = window.yaar || {};

  var registration = null;

  window.yaar.app = {
    register: function(config) {
      registration = config;
      // Notify parent that this app supports the protocol
      window.parent.postMessage({ type: 'yaar:app-ready', appId: config.appId }, '*');
    }
  };

  window.addEventListener('message', function(e) {
    if (!e.data || !e.data.type) return;
    var msg = e.data;
    var requestId = msg.requestId;

    if (msg.type === 'yaar:app-manifest-request') {
      if (!registration) {
        window.parent.postMessage({
          type: 'yaar:app-manifest-response',
          requestId: requestId,
          manifest: null,
          error: 'No app registered'
        }, '*');
        return;
      }
      // Build manifest: strip handlers, expose only descriptions + schemas
      var manifest = {
        appId: registration.appId,
        name: registration.name,
        state: {},
        commands: {}
      };
      if (registration.state) {
        for (var key in registration.state) {
          var s = registration.state[key];
          manifest.state[key] = { description: s.description };
          if (s.schema) manifest.state[key].schema = s.schema;
        }
      }
      if (registration.commands) {
        for (var key in registration.commands) {
          var c = registration.commands[key];
          manifest.commands[key] = { description: c.description };
          if (c.params) manifest.commands[key].params = c.params;
          if (c.returns) manifest.commands[key].returns = c.returns;
        }
      }
      window.parent.postMessage({
        type: 'yaar:app-manifest-response',
        requestId: requestId,
        manifest: manifest
      }, '*');
      return;
    }

    if (msg.type === 'yaar:app-query-request') {
      if (!registration || !registration.state || !registration.state[msg.stateKey]) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: 'Unknown state key: ' + msg.stateKey
        }, '*');
        return;
      }
      try {
        var result = registration.state[msg.stateKey].handler();
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-query-response',
            requestId: requestId,
            data: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: String(err)
        }, '*');
      }
      return;
    }

    if (msg.type === 'yaar:app-command-request') {
      if (!registration || !registration.commands || !registration.commands[msg.command]) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: 'Unknown command: ' + msg.command
        }, '*');
        return;
      }
      try {
        var result = registration.commands[msg.command].handler(msg.params);
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-command-response',
            requestId: requestId,
            result: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: String(err)
        }, '*');
      }
      return;
    }
  });
})();
</script>
</head>
<body>
  <div id="app"></div>
  <script type="module">
// ../../sandbox/1770712069157/src/main.ts
var root = document.getElementById("app") || document.body;
root.innerHTML = "";
Object.assign(root.style, {
  margin: "0",
  width: "100vw",
  height: "100vh",
  overflow: "hidden",
  background: "#87ceeb",
  fontFamily: "system-ui, sans-serif"
});
var hud = document.createElement("div");
Object.assign(hud.style, {
  position: "fixed",
  top: "10px",
  left: "10px",
  color: "white",
  background: "rgba(0,0,0,0.45)",
  padding: "8px 10px",
  fontSize: "13px",
  borderRadius: "8px",
  zIndex: "10"
});
root.appendChild(hud);
var center = document.createElement("div");
Object.assign(center.style, {
  position: "fixed",
  left: "50%",
  top: "50%",
  width: "14px",
  height: "14px",
  transform: "translate(-50%, -50%)",
  pointerEvents: "none",
  zIndex: "10",
  color: "#fff"
});
center.textContent = "+";
root.appendChild(center);
var msg = document.createElement("div");
Object.assign(msg.style, {
  position: "fixed",
  bottom: "12px",
  left: "10px",
  color: "#fff",
  background: "rgba(0,0,0,0.45)",
  padding: "6px 10px",
  fontSize: "12px",
  borderRadius: "8px",
  zIndex: "10"
});
msg.textContent = "Click to lock mouse. WASD move, Space jump, LMB break, RMB place, 1-4 block.";
root.appendChild(msg);
async function boot() {
  const THREE = await import("https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js");
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  root.appendChild(renderer.domElement);
  const scene = new THREE.Scene();
  scene.background = new THREE.Color("#87ceeb");
  scene.fog = new THREE.Fog("#87ceeb", 25, 100);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);
  scene.add(new THREE.AmbientLight(16777215, 0.45));
  const sun = new THREE.DirectionalLight(16777215, 1);
  sun.position.set(30, 50, 10);
  sun.castShadow = true;
  scene.add(sun);
  const worldGroup = new THREE.Group();
  scene.add(worldGroup);
  const WORLD_X = 40, WORLD_Z = 40, MAX_H = 12;
  let selected = 1;
  const names = { 1: "Grass", 2: "Dirt", 3: "Stone", 4: "Wood" };
  const mats = {
    1: new THREE.MeshStandardMaterial({ color: "#4caf50" }),
    2: new THREE.MeshStandardMaterial({ color: "#8d6e63" }),
    3: new THREE.MeshStandardMaterial({ color: "#9e9e9e" }),
    4: new THREE.MeshStandardMaterial({ color: "#8b5a2b" })
  };
  const geo = new THREE.BoxGeometry(1, 1, 1);
  const blocks = /* @__PURE__ */ new Map();
  const meshes = /* @__PURE__ */ new Map();
  const key = (x, y, z) => `${x},${y},${z}`;
  function getBlock(x, y, z) {
    return blocks.get(key(x, y, z)) || 0;
  }
  function setBlock(x, y, z, id) {
    if (x < 0 || z < 0 || x >= WORLD_X || z >= WORLD_Z || y < 0 || y > MAX_H) return;
    const k = key(x, y, z);
    const ex = meshes.get(k);
    if (ex) {
      worldGroup.remove(ex);
      meshes.delete(k);
    }
    if (!id) {
      blocks.delete(k);
      return;
    }
    blocks.set(k, id);
    const m = new THREE.Mesh(geo, mats[id]);
    m.position.set(x + 0.5, y + 0.5, z + 0.5);
    m.castShadow = true;
    m.receiveShadow = true;
    m.userData.blockPos = { x, y, z };
    worldGroup.add(m);
    meshes.set(k, m);
  }
  for (let x = 0; x < WORLD_X; x++) {
    for (let z = 0; z < WORLD_Z; z++) {
      const h = 4 + Math.floor((Math.sin(x * 0.35) + Math.cos(z * 0.28)) * 1.7 + Math.random() * 1.2);
      const top = Math.max(2, Math.min(MAX_H - 2, h));
      for (let y = 0; y <= top; y++) setBlock(x, y, z, y === top ? 1 : y > top - 2 ? 2 : 3);
      if (Math.random() < 0.04 && x > 2 && z > 2 && x < WORLD_X - 2 && z < WORLD_Z - 2) {
        const base = top + 1, height = 2 + Math.floor(Math.random() * 2);
        for (let t = 0; t < height; t++) setBlock(x, base + t, z, 4);
      }
    }
  }
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: "#6ca0dc" }));
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -0.01;
  floor.receiveShadow = true;
  scene.add(floor);
  const player = { pos: new THREE.Vector3(WORLD_X / 2, 12, WORLD_Z / 2), vel: new THREE.Vector3(), radius: 0.3, height: 1.8, onGround: false, yaw: 0, pitch: 0 };
  function collides(px, py, pz) {
    const minX = px - player.radius, maxX = px + player.radius;
    const minY = py, maxY = py + player.height;
    const minZ = pz - player.radius, maxZ = pz + player.radius;
    for (let x = Math.floor(minX); x <= Math.floor(maxX); x++) {
      for (let y = Math.floor(minY); y <= Math.floor(maxY); y++) {
        for (let z = Math.floor(minZ); z <= Math.floor(maxZ); z++) {
          if (getBlock(x, y, z) !== 0) return true;
        }
      }
    }
    return false;
  }
  function moveAxis(axis, amount) {
    if (!amount) return;
    const next = player.pos.clone();
    next[axis] += amount;
    if (!collides(next.x, next.y, next.z)) {
      player.pos.copy(next);
      return;
    }
    const step = Math.sign(amount) * 0.02;
    let moved = 0;
    while (Math.abs(moved + step) <= Math.abs(amount)) {
      const t = player.pos.clone();
      t[axis] += moved + step;
      if (collides(t.x, t.y, t.z)) break;
      moved += step;
    }
    player.pos[axis] += moved;
    if (axis === "y") {
      if (amount < 0) player.onGround = true;
      player.vel.y = 0;
    }
    if (axis === "x") player.vel.x = 0;
    if (axis === "z") player.vel.z = 0;
  }
  const keys = /* @__PURE__ */ new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);
    if (k >= "1" && k <= "4") selected = Number(k);
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));
  renderer.domElement.addEventListener("click", () => renderer.domElement.requestPointerLock());
  window.addEventListener("mousemove", (e) => {
    if (document.pointerLockElement !== renderer.domElement) return;
    player.yaw -= e.movementX * 22e-4;
    player.pitch -= e.movementY * 22e-4;
    player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch));
  });
  renderer.domElement.addEventListener("contextmenu", (e) => e.preventDefault());
  renderer.domElement.addEventListener("mousedown", (e) => {
    const ray = new THREE.Raycaster();
    ray.setFromCamera(new THREE.Vector2(0, 0), camera);
    const hits = ray.intersectObjects(worldGroup.children, false);
    if (!hits.length) return;
    const hit = hits[0];
    const p = hit.object.userData.blockPos;
    if (!p || hit.distance > 7) return;
    if (e.button === 0) {
      setBlock(p.x, p.y, p.z, 0);
    } else if (e.button === 2) {
      const n = hit.face?.normal || new THREE.Vector3();
      const ax = p.x + Math.round(n.x), ay = p.y + Math.round(n.y), az = p.z + Math.round(n.z);
      if (getBlock(ax, ay, az) === 0 && !collides(ax + 0.5, ay, az + 0.5)) setBlock(ax, ay, az, selected);
    }
  });
  function updateHud() {
    hud.textContent = `Minecraft 3D Lite | Block: ${selected} (${names[selected]}) | XYZ: ${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)}`;
  }
  let prev = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - prev) / 1e3);
    prev = now;
    const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
    const right = new THREE.Vector3(forward.z, 0, -forward.x);
    const wish = new THREE.Vector3();
    if (keys.has("w")) wish.add(forward);
    if (keys.has("s")) wish.sub(forward);
    if (keys.has("d")) wish.add(right);
    if (keys.has("a")) wish.sub(right);
    if (wish.lengthSq() > 0) {
      wish.normalize().multiplyScalar(6.5);
      player.vel.x += (wish.x - player.vel.x) * Math.min(1, dt * 14);
      player.vel.z += (wish.z - player.vel.z) * Math.min(1, dt * 14);
    } else {
      player.vel.x *= Math.pow(1e-4, dt);
      player.vel.z *= Math.pow(1e-4, dt);
    }
    if (keys.has(" ") && player.onGround) {
      player.vel.y = 7.5;
      player.onGround = false;
    }
    player.vel.y -= 18 * dt;
    player.onGround = false;
    moveAxis("x", player.vel.x * dt);
    moveAxis("z", player.vel.z * dt);
    moveAxis("y", player.vel.y * dt);
    if (player.pos.y < -20) {
      player.pos.set(WORLD_X / 2, 14, WORLD_Z / 2);
      player.vel.set(0, 0, 0);
    }
    camera.position.set(player.pos.x, player.pos.y + 1.62, player.pos.z);
    camera.rotation.order = "YXZ";
    camera.rotation.y = player.yaw;
    camera.rotation.x = player.pitch;
    updateHud();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}
boot().catch((err) => {
  const pre = document.createElement("pre");
  pre.textContent = `Failed to load 3D engine: ${String(err)}`;
  pre.style.color = "white";
  pre.style.padding = "12px";
  root.appendChild(pre);
});

  </script>
</body>
</html>