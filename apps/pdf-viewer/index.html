<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Viewer &amp; Export</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  </style>
  <script>
(function() {
  if (window.__yaarCaptureInstalled) return;
  window.__yaarCaptureInstalled = true;

  window.addEventListener('message', function(e) {
    if (!e.data || e.data.type !== 'yaar:capture-request') return;
    var requestId = e.data.requestId;
    var imageData = null;

    try {
      // Try capturing the largest canvas element
      var canvases = document.querySelectorAll('canvas');
      if (canvases.length > 0) {
        var largest = null;
        var largestArea = 0;
        for (var i = 0; i < canvases.length; i++) {
          var area = canvases[i].width * canvases[i].height;
          if (area > largestArea) {
            largestArea = area;
            largest = canvases[i];
          }
        }
        if (largest) {
          imageData = largest.toDataURL('image/png');
        }
      }

      // Fall back to SVG capture
      if (!imageData) {
        var svgs = document.querySelectorAll('svg');
        if (svgs.length > 0) {
          var largest = null;
          var largestArea = 0;
          for (var i = 0; i < svgs.length; i++) {
            var rect = svgs[i].getBoundingClientRect();
            var area = rect.width * rect.height;
            if (area > largestArea) {
              largestArea = area;
              largest = svgs[i];
            }
          }
          if (largest) {
            var serializer = new XMLSerializer();
            var svgStr = serializer.serializeToString(largest);
            var rect = largest.getBoundingClientRect();
            var w = rect.width || 300;
            var h = rect.height || 150;
            var img = new Image();
            var blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
            var url = URL.createObjectURL(blob);
            img.onload = function() {
              var c = document.createElement('canvas');
              c.width = w;
              c.height = h;
              var ctx = c.getContext('2d');
              ctx.drawImage(img, 0, 0, w, h);
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: c.toDataURL('image/png')
              }, '*');
            };
            img.onerror = function() {
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: null
              }, '*');
            };
            img.src = url;
            return; // async path — response sent from onload/onerror
          }
        }
      }
    } catch (ex) {
      // Capture failed, imageData stays null
    }

    window.parent.postMessage({
      type: 'yaar:capture-response',
      requestId: requestId,
      imageData: imageData
    }, '*');
  });
})();
</script>
  <script>
(function() {
  if (window.__yaarStorageInstalled) return;
  window.__yaarStorageInstalled = true;

  function encodePath(p) {
    return p.split('/').map(encodeURIComponent).join('/');
  }

  window.yaar = window.yaar || {};
  window.yaar.storage = {
    async save(path, data) {
      var body;
      if (typeof data === 'string') {
        body = data;
      } else if (data instanceof Blob) {
        body = await data.arrayBuffer();
      } else if (data instanceof ArrayBuffer) {
        body = data;
      } else if (data instanceof Uint8Array) {
        body = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      } else {
        body = String(data);
      }
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'POST', body: body });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Save failed');
      }
      return res.json();
    },

    async read(path, options) {
      var mode = (options && options.as) || 'auto';
      var res = await fetch('/api/storage/' + encodePath(path));
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Read failed');
      }
      if (mode === 'blob') return res.blob();
      if (mode === 'arraybuffer') return res.arrayBuffer();
      if (mode === 'json') return res.json();
      if (mode === 'text') return res.text();
      // auto: guess from content-type
      var ct = res.headers.get('content-type') || '';
      if (ct.includes('json')) return res.json();
      if (ct.startsWith('text/')) return res.text();
      return res.blob();
    },

    async list(dirPath) {
      var p = dirPath ? encodePath(dirPath) : '';
      var res = await fetch('/api/storage/' + p + '?list=true');
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'List failed');
      }
      return res.json();
    },

    async remove(path) {
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'DELETE' });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Delete failed');
      }
      return res.json();
    },

    url: function(path) {
      return '/api/storage/' + encodePath(path);
    }
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarFetchProxyInstalled) return;
  window.__yaarFetchProxyInstalled = true;

  var realFetch = window.fetch.bind(window);

  window.fetch = function(input, init) {
    var url;
    if (input instanceof Request) {
      url = input.url;
    } else {
      url = String(input);
    }

    // Relative URLs and same-origin — pass through
    if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {
      return realFetch(input, init);
    }
    try {
      var parsed = new URL(url, location.origin);
      if (parsed.origin === location.origin) {
        return realFetch(input, init);
      }
    } catch(e) {
      return realFetch(input, init);
    }

    // Cross-origin — route through proxy
    var method = (init && init.method) || (input instanceof Request ? input.method : 'GET');
    var headers = {};
    if (init && init.headers) {
      if (init.headers instanceof Headers) {
        init.headers.forEach(function(v, k) { headers[k] = v; });
      } else if (Array.isArray(init.headers)) {
        init.headers.forEach(function(pair) { headers[pair[0]] = pair[1]; });
      } else {
        headers = Object.assign({}, init.headers);
      }
    } else if (input instanceof Request) {
      input.headers.forEach(function(v, k) { headers[k] = v; });
    }

    var bodyPromise;
    if (init && init.body != null) {
      if (typeof init.body === 'string') {
        bodyPromise = Promise.resolve(init.body);
      } else {
        bodyPromise = new Response(init.body).text();
      }
    } else if (input instanceof Request && method !== 'GET' && method !== 'HEAD') {
      bodyPromise = input.text();
    } else {
      bodyPromise = Promise.resolve(undefined);
    }

    return bodyPromise.then(function(bodyStr) {
      var payload = { url: url, method: method, headers: headers };
      if (bodyStr !== undefined) payload.body = bodyStr;

      return realFetch('/api/fetch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    }).then(function(proxyRes) {
      if (!proxyRes.ok) {
        return proxyRes.json().then(function(err) {
          throw new Error(err.error || 'Fetch proxy error: ' + proxyRes.status);
        });
      }
      return proxyRes.json();
    }).then(function(data) {
      var body;
      if (data.bodyEncoding === 'base64') {
        var bin = atob(data.body);
        var bytes = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        body = bytes.buffer;
      } else {
        body = data.body;
      }
      return new Response(body, {
        status: data.status,
        statusText: data.statusText,
        headers: data.headers
      });
    });
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarAppProtocolInstalled) return;
  window.__yaarAppProtocolInstalled = true;

  window.yaar = window.yaar || {};

  var registration = null;

  window.yaar.app = {
    register: function(config) {
      registration = config;
      // Notify parent that this app supports the protocol
      window.parent.postMessage({ type: 'yaar:app-ready', appId: config.appId }, '*');
    }
  };

  window.addEventListener('message', function(e) {
    if (!e.data || !e.data.type) return;
    var msg = e.data;
    var requestId = msg.requestId;

    if (msg.type === 'yaar:app-manifest-request') {
      if (!registration) {
        window.parent.postMessage({
          type: 'yaar:app-manifest-response',
          requestId: requestId,
          manifest: null,
          error: 'No app registered'
        }, '*');
        return;
      }
      // Build manifest: strip handlers, expose only descriptions + schemas
      var manifest = {
        appId: registration.appId,
        name: registration.name,
        state: {},
        commands: {}
      };
      if (registration.state) {
        for (var key in registration.state) {
          var s = registration.state[key];
          manifest.state[key] = { description: s.description };
          if (s.schema) manifest.state[key].schema = s.schema;
        }
      }
      if (registration.commands) {
        for (var key in registration.commands) {
          var c = registration.commands[key];
          manifest.commands[key] = { description: c.description };
          if (c.params) manifest.commands[key].params = c.params;
          if (c.returns) manifest.commands[key].returns = c.returns;
        }
      }
      window.parent.postMessage({
        type: 'yaar:app-manifest-response',
        requestId: requestId,
        manifest: manifest
      }, '*');
      return;
    }

    if (msg.type === 'yaar:app-query-request') {
      if (!registration || !registration.state || !registration.state[msg.stateKey]) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: 'Unknown state key: ' + msg.stateKey
        }, '*');
        return;
      }
      try {
        var result = registration.state[msg.stateKey].handler();
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-query-response',
            requestId: requestId,
            data: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: String(err)
        }, '*');
      }
      return;
    }

    if (msg.type === 'yaar:app-command-request') {
      if (!registration || !registration.commands || !registration.commands[msg.command]) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: 'Unknown command: ' + msg.command
        }, '*');
        return;
      }
      try {
        var result = registration.commands[msg.command].handler(msg.params);
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-command-response',
            requestId: requestId,
            result: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: String(err)
        }, '*');
      }
      return;
    }
  });
})();
</script>
</head>
<body>
  <div id="app"></div>
  <script type="module">
// ../../sandbox/1770710456876/src/main.ts
var root = document.getElementById("app");
if (!root) throw new Error("Missing app root");
root.innerHTML = `
  <style>
    :root {
      color-scheme: light dark;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    body { margin: 0; }
    .wrap { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
    .top {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #d0d7de;
      background: #f6f8fa;
      flex-wrap: wrap;
    }
    .top button, .top select, .top input, .top textarea {
      font: inherit;
    }
    .top button {
      padding: 6px 10px;
      border: 1px solid #b6c2cf;
      border-radius: 8px;
      background: white;
      cursor: pointer;
    }
    .top button.active { background: #0969da; color: #fff; border-color: #0969da; }
    .top .spacer { flex: 1; }
    .pane { height: calc(100vh - 58px); }
    .hidden { display: none !important; }
    .viewer-pane { display: grid; grid-template-rows: auto 1fr; }
    .viewer-controls {
      display: flex;
      gap: 8px;
      padding: 10px;
      border-bottom: 1px solid #d0d7de;
      align-items: center;
      flex-wrap: wrap;
    }
    .viewer-frame {
      width: 100%;
      height: 100%;
      border: 0;
      background: #f0f0f0;
    }
    .drop {
      border: 2px dashed #9aa4b2;
      border-radius: 12px;
      padding: 28px;
      margin: 12px;
      text-align: center;
      color: #57606a;
    }
    .drop.drag { border-color: #0969da; color: #0969da; }
    .export-pane { display: grid; grid-template-columns: 1fr 1fr; height: 100%; }
    .left, .right { padding: 10px; overflow: auto; }
    .left { border-right: 1px solid #d0d7de; }
    textarea {
      width: 100%;
      height: calc(100% - 60px);
      min-height: 220px;
      resize: vertical;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 10px;
      box-sizing: border-box;
      background: white;
      color: #111;
    }
    .preview {
      background: white;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 20px;
      min-height: 92%;
      color: #111;
    }
    .hint { color: #57606a; font-size: 12px; }
    .status { font-size: 12px; color: #57606a; }
    @media print {
      body * { visibility: hidden !important; }
      #print-area, #print-area * { visibility: visible !important; }
      #print-area {
        position: fixed;
        inset: 0;
        background: white;
        color: #000;
        padding: 20mm;
      }
    }
  </style>

  <div class="wrap">
    <div class="top">
      <button id="btn-viewer" class="active">PDF Viewer</button>
      <button id="btn-export">Export to PDF</button>
      <div class="spacer"></div>
      <span id="global-status" class="status">Ready</span>
    </div>

    <div id="viewer-pane" class="pane viewer-pane">
      <div class="viewer-controls">
        <input id="file-input" type="file" accept="application/pdf" />
        <button id="open-storage">Open from Storage Path</button>
        <input id="storage-path" type="text" placeholder="e.g. mydocs/report.pdf" style="min-width: 260px; padding: 6px 8px; border-radius: 8px; border: 1px solid #d0d7de;" />
        <button id="clear-pdf">Clear</button>
        <span id="pdf-status" class="status">No PDF loaded.</span>
      </div>
      <div id="drop" class="drop">Drop a PDF file here, or use the file picker above.</div>
      <iframe id="pdf-frame" class="viewer-frame hidden"></iframe>
    </div>

    <div id="export-pane" class="pane export-pane hidden">
      <div class="left">
        <h3 style="margin: 0 0 8px;">Content</h3>
        <p class="hint" style="margin-top: 0;">Type plain text or basic HTML. Use preview, then click \u201CExport PDF\u201D.</p>
        <textarea id="content-input" placeholder="Paste document/content here..."></textarea>
      </div>
      <div class="right">
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button id="preview-btn">Refresh Preview</button>
          <button id="export-btn">Export PDF</button>
          <button id="save-html-btn">Save HTML to Storage</button>
        </div>
        <div id="print-area" class="preview"></div>
      </div>
    </div>
  </div>
`;
var els = {
  btnViewer: document.getElementById("btn-viewer"),
  btnExport: document.getElementById("btn-export"),
  viewerPane: document.getElementById("viewer-pane"),
  exportPane: document.getElementById("export-pane"),
  globalStatus: document.getElementById("global-status"),
  fileInput: document.getElementById("file-input"),
  pdfFrame: document.getElementById("pdf-frame"),
  pdfStatus: document.getElementById("pdf-status"),
  drop: document.getElementById("drop"),
  clearPdf: document.getElementById("clear-pdf"),
  openStorage: document.getElementById("open-storage"),
  storagePath: document.getElementById("storage-path"),
  contentInput: document.getElementById("content-input"),
  previewBtn: document.getElementById("preview-btn"),
  exportBtn: document.getElementById("export-btn"),
  saveHtmlBtn: document.getElementById("save-html-btn"),
  printArea: document.getElementById("print-area")
};
var mode = "viewer";
var currentPdfUrl = null;
function setMode(next) {
  mode = next;
  const viewer = next === "viewer";
  els.viewerPane.classList.toggle("hidden", !viewer);
  els.exportPane.classList.toggle("hidden", viewer);
  els.btnViewer.classList.toggle("active", viewer);
  els.btnExport.classList.toggle("active", !viewer);
  els.globalStatus.textContent = viewer ? "Viewer mode" : "Export mode";
}
function revokeCurrentPdfUrl() {
  if (currentPdfUrl && currentPdfUrl.startsWith("blob:")) URL.revokeObjectURL(currentPdfUrl);
  currentPdfUrl = null;
}
function showPdfUrl(url, label) {
  revokeCurrentPdfUrl();
  currentPdfUrl = url;
  els.pdfFrame.src = url;
  els.pdfFrame.classList.remove("hidden");
  els.drop.classList.add("hidden");
  els.pdfStatus.textContent = `Loaded: ${label}`;
  els.globalStatus.textContent = "PDF loaded";
}
async function openFromStorage(path) {
  const clean = path.trim().replace(/^\/+/, "");
  if (!clean) {
    els.pdfStatus.textContent = "Enter a storage path first.";
    return;
  }
  const storage = window.yaar?.storage;
  if (!storage) {
    els.pdfStatus.textContent = "Storage API unavailable in this app context.";
    return;
  }
  try {
    const bytes = await storage.read(clean, { as: "arraybuffer" });
    const blob = new Blob([bytes], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);
    showPdfUrl(url, clean);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    els.pdfStatus.textContent = `Failed to read storage file: ${msg}`;
  }
}
function renderPreview() {
  const raw = els.contentInput.value.trim();
  if (!raw) {
    els.printArea.innerHTML = '<p style="color:#57606a;">No content yet.</p>';
    return;
  }
  const looksLikeHtml = /<\/?[a-z][\s\S]*>/i.test(raw);
  if (looksLikeHtml) {
    els.printArea.innerHTML = raw;
  } else {
    const escaped = raw.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#39;").replaceAll("\n", "<br>");
    els.printArea.innerHTML = `<div>${escaped}</div>`;
  }
}
async function saveHtmlSnapshot() {
  const storage = window.yaar?.storage;
  if (!storage) {
    els.globalStatus.textContent = "Storage API unavailable";
    return;
  }
  const ts = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  const path = `pdf-viewer/exports/export-${ts}.html`;
  await storage.save(path, els.printArea.innerHTML || "<p></p>");
  els.globalStatus.textContent = `Saved HTML: ${path}`;
}
els.btnViewer.addEventListener("click", () => setMode("viewer"));
els.btnExport.addEventListener("click", () => setMode("export"));
els.fileInput.addEventListener("change", () => {
  const file = els.fileInput.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  showPdfUrl(url, file.name);
});
els.clearPdf.addEventListener("click", () => {
  revokeCurrentPdfUrl();
  els.pdfFrame.src = "";
  els.pdfFrame.classList.add("hidden");
  els.drop.classList.remove("hidden");
  els.pdfStatus.textContent = "No PDF loaded.";
  els.globalStatus.textContent = "Viewer cleared";
});
els.openStorage.addEventListener("click", () => openFromStorage(els.storagePath.value));
els.storagePath.addEventListener("keydown", (e) => {
  if (e.key === "Enter") openFromStorage(els.storagePath.value);
});
els.drop.addEventListener("dragover", (e) => {
  e.preventDefault();
  els.drop.classList.add("drag");
});
els.drop.addEventListener("dragleave", () => els.drop.classList.remove("drag"));
els.drop.addEventListener("drop", (e) => {
  e.preventDefault();
  els.drop.classList.remove("drag");
  const file = e.dataTransfer?.files?.[0];
  if (!file) return;
  if (file.type !== "application/pdf" && !file.name.toLowerCase().endsWith(".pdf")) {
    els.pdfStatus.textContent = "Only PDF files are supported.";
    return;
  }
  const url = URL.createObjectURL(file);
  showPdfUrl(url, file.name);
});
els.previewBtn.addEventListener("click", () => {
  renderPreview();
  els.globalStatus.textContent = "Preview updated";
});
els.exportBtn.addEventListener("click", () => {
  renderPreview();
  els.globalStatus.textContent = "Opening print dialog... choose Save as PDF";
  window.print();
});
els.saveHtmlBtn.addEventListener("click", async () => {
  renderPreview();
  try {
    await saveHtmlSnapshot();
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    els.globalStatus.textContent = `Save failed: ${msg}`;
  }
});
els.contentInput.value = `<h1>Document Title</h1>
<p>Write or paste your content here, then click <strong>Export PDF</strong>.</p>
<ul><li>Supports plain text</li><li>Supports basic HTML</li></ul>`;
renderPreview();
setMode("viewer");
window.addEventListener("beforeunload", () => revokeCurrentPdfUrl());

  </script>
</body>
</html>