<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Word Lite</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  </style>
  <script>
(function() {
  if (window.__yaarCaptureInstalled) return;
  window.__yaarCaptureInstalled = true;

  window.addEventListener('message', function(e) {
    if (!e.data || e.data.type !== 'yaar:capture-request') return;
    var requestId = e.data.requestId;
    var imageData = null;

    try {
      // Try capturing the largest canvas element
      var canvases = document.querySelectorAll('canvas');
      if (canvases.length > 0) {
        var largest = null;
        var largestArea = 0;
        for (var i = 0; i < canvases.length; i++) {
          var area = canvases[i].width * canvases[i].height;
          if (area > largestArea) {
            largestArea = area;
            largest = canvases[i];
          }
        }
        if (largest) {
          imageData = largest.toDataURL('image/png');
        }
      }

      // Fall back to SVG capture
      if (!imageData) {
        var svgs = document.querySelectorAll('svg');
        if (svgs.length > 0) {
          var largest = null;
          var largestArea = 0;
          for (var i = 0; i < svgs.length; i++) {
            var rect = svgs[i].getBoundingClientRect();
            var area = rect.width * rect.height;
            if (area > largestArea) {
              largestArea = area;
              largest = svgs[i];
            }
          }
          if (largest) {
            var serializer = new XMLSerializer();
            var svgStr = serializer.serializeToString(largest);
            var rect = largest.getBoundingClientRect();
            var w = rect.width || 300;
            var h = rect.height || 150;
            var img = new Image();
            var blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
            var url = URL.createObjectURL(blob);
            img.onload = function() {
              var c = document.createElement('canvas');
              c.width = w;
              c.height = h;
              var ctx = c.getContext('2d');
              ctx.drawImage(img, 0, 0, w, h);
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: c.toDataURL('image/png')
              }, '*');
            };
            img.onerror = function() {
              URL.revokeObjectURL(url);
              window.parent.postMessage({
                type: 'yaar:capture-response',
                requestId: requestId,
                imageData: null
              }, '*');
            };
            img.src = url;
            return; // async path — response sent from onload/onerror
          }
        }
      }
    } catch (ex) {
      // Capture failed, imageData stays null
    }

    window.parent.postMessage({
      type: 'yaar:capture-response',
      requestId: requestId,
      imageData: imageData
    }, '*');
  });
})();
</script>
  <script>
(function() {
  if (window.__yaarStorageInstalled) return;
  window.__yaarStorageInstalled = true;

  function encodePath(p) {
    return p.split('/').map(encodeURIComponent).join('/');
  }

  window.yaar = window.yaar || {};
  window.yaar.storage = {
    async save(path, data) {
      var body;
      if (typeof data === 'string') {
        body = data;
      } else if (data instanceof Blob) {
        body = await data.arrayBuffer();
      } else if (data instanceof ArrayBuffer) {
        body = data;
      } else if (data instanceof Uint8Array) {
        body = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      } else {
        body = String(data);
      }
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'POST', body: body });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Save failed');
      }
      return res.json();
    },

    async read(path, options) {
      var mode = (options && options.as) || 'auto';
      var res = await fetch('/api/storage/' + encodePath(path));
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Read failed');
      }
      if (mode === 'blob') return res.blob();
      if (mode === 'arraybuffer') return res.arrayBuffer();
      if (mode === 'json') return res.json();
      if (mode === 'text') return res.text();
      // auto: guess from content-type
      var ct = res.headers.get('content-type') || '';
      if (ct.includes('json')) return res.json();
      if (ct.startsWith('text/')) return res.text();
      return res.blob();
    },

    async list(dirPath) {
      var p = dirPath ? encodePath(dirPath) : '';
      var res = await fetch('/api/storage/' + p + '?list=true');
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'List failed');
      }
      return res.json();
    },

    async remove(path) {
      var res = await fetch('/api/storage/' + encodePath(path), { method: 'DELETE' });
      if (!res.ok) {
        var err = await res.json().catch(function() { return { error: res.statusText }; });
        throw new Error(err.error || 'Delete failed');
      }
      return res.json();
    },

    url: function(path) {
      return '/api/storage/' + encodePath(path);
    }
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarFetchProxyInstalled) return;
  window.__yaarFetchProxyInstalled = true;

  var realFetch = window.fetch.bind(window);

  window.fetch = function(input, init) {
    var url;
    if (input instanceof Request) {
      url = input.url;
    } else {
      url = String(input);
    }

    // Relative URLs and same-origin — pass through
    if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {
      return realFetch(input, init);
    }
    try {
      var parsed = new URL(url, location.origin);
      if (parsed.origin === location.origin) {
        return realFetch(input, init);
      }
    } catch(e) {
      return realFetch(input, init);
    }

    // Cross-origin — route through proxy
    var method = (init && init.method) || (input instanceof Request ? input.method : 'GET');
    var headers = {};
    if (init && init.headers) {
      if (init.headers instanceof Headers) {
        init.headers.forEach(function(v, k) { headers[k] = v; });
      } else if (Array.isArray(init.headers)) {
        init.headers.forEach(function(pair) { headers[pair[0]] = pair[1]; });
      } else {
        headers = Object.assign({}, init.headers);
      }
    } else if (input instanceof Request) {
      input.headers.forEach(function(v, k) { headers[k] = v; });
    }

    var bodyPromise;
    if (init && init.body != null) {
      if (typeof init.body === 'string') {
        bodyPromise = Promise.resolve(init.body);
      } else {
        bodyPromise = new Response(init.body).text();
      }
    } else if (input instanceof Request && method !== 'GET' && method !== 'HEAD') {
      bodyPromise = input.text();
    } else {
      bodyPromise = Promise.resolve(undefined);
    }

    return bodyPromise.then(function(bodyStr) {
      var payload = { url: url, method: method, headers: headers };
      if (bodyStr !== undefined) payload.body = bodyStr;

      return realFetch('/api/fetch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    }).then(function(proxyRes) {
      if (!proxyRes.ok) {
        return proxyRes.json().then(function(err) {
          throw new Error(err.error || 'Fetch proxy error: ' + proxyRes.status);
        });
      }
      return proxyRes.json();
    }).then(function(data) {
      var body;
      if (data.bodyEncoding === 'base64') {
        var bin = atob(data.body);
        var bytes = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        body = bytes.buffer;
      } else {
        body = data.body;
      }
      return new Response(body, {
        status: data.status,
        statusText: data.statusText,
        headers: data.headers
      });
    });
  };
})();
</script>
  <script>
(function() {
  if (window.__yaarAppProtocolInstalled) return;
  window.__yaarAppProtocolInstalled = true;

  window.yaar = window.yaar || {};

  var registration = null;

  window.yaar.app = {
    register: function(config) {
      registration = config;
      // Notify parent that this app supports the protocol
      window.parent.postMessage({ type: 'yaar:app-ready', appId: config.appId }, '*');
    }
  };

  window.addEventListener('message', function(e) {
    if (!e.data || !e.data.type) return;
    var msg = e.data;
    var requestId = msg.requestId;

    if (msg.type === 'yaar:app-manifest-request') {
      if (!registration) {
        window.parent.postMessage({
          type: 'yaar:app-manifest-response',
          requestId: requestId,
          manifest: null,
          error: 'No app registered'
        }, '*');
        return;
      }
      // Build manifest: strip handlers, expose only descriptions + schemas
      var manifest = {
        appId: registration.appId,
        name: registration.name,
        state: {},
        commands: {}
      };
      if (registration.state) {
        for (var key in registration.state) {
          var s = registration.state[key];
          manifest.state[key] = { description: s.description };
          if (s.schema) manifest.state[key].schema = s.schema;
        }
      }
      if (registration.commands) {
        for (var key in registration.commands) {
          var c = registration.commands[key];
          manifest.commands[key] = { description: c.description };
          if (c.params) manifest.commands[key].params = c.params;
          if (c.returns) manifest.commands[key].returns = c.returns;
        }
      }
      window.parent.postMessage({
        type: 'yaar:app-manifest-response',
        requestId: requestId,
        manifest: manifest
      }, '*');
      return;
    }

    if (msg.type === 'yaar:app-query-request') {
      if (!registration || !registration.state || !registration.state[msg.stateKey]) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: 'Unknown state key: ' + msg.stateKey
        }, '*');
        return;
      }
      try {
        var result = registration.state[msg.stateKey].handler();
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-query-response',
              requestId: requestId,
              data: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-query-response',
            requestId: requestId,
            data: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-query-response',
          requestId: requestId,
          data: null,
          error: String(err)
        }, '*');
      }
      return;
    }

    if (msg.type === 'yaar:app-command-request') {
      if (!registration || !registration.commands || !registration.commands[msg.command]) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: 'Unknown command: ' + msg.command
        }, '*');
        return;
      }
      try {
        var result = registration.commands[msg.command].handler(msg.params);
        // Handle async handlers
        if (result && typeof result.then === 'function') {
          result.then(function(data) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: data
            }, '*');
          }).catch(function(err) {
            window.parent.postMessage({
              type: 'yaar:app-command-response',
              requestId: requestId,
              result: null,
              error: String(err)
            }, '*');
          });
        } else {
          window.parent.postMessage({
            type: 'yaar:app-command-response',
            requestId: requestId,
            result: result
          }, '*');
        }
      } catch (err) {
        window.parent.postMessage({
          type: 'yaar:app-command-response',
          requestId: requestId,
          result: null,
          error: String(err)
        }, '*');
      }
      return;
    }
  });
})();
</script>
</head>
<body>
  <script type="module">
// ../../sandbox/1770684810395/src/styles.ts
var styles = `
:root {
  --bg: #0f172a;
  --panel: #111827;
  --toolbar: #1f2937;
  --surface: #ffffff;
  --text: #111827;
  --muted: #6b7280;
  --accent: #2563eb;
  --border: #e5e7eb;
}

* { box-sizing: border-box; }
html, body {
  margin: 0;
  height: 100%;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
}

#app {
  height: 100%;
}

.app-shell {
  display: grid;
  grid-template-rows: auto auto 1fr auto;
  height: 100%;
  color: #e5e7eb;
}

.topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--panel);
  border-bottom: 1px solid #374151;
}

.brand {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 700;
}

.brand-badge {
  width: 26px;
  height: 26px;
  border-radius: 7px;
  background: linear-gradient(135deg, #3b82f6, #1d4ed8);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 13px;
}

.toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 10px 12px;
  background: var(--toolbar);
  border-bottom: 1px solid #374151;
}

.group {
  display: inline-flex;
  gap: 6px;
  padding-right: 8px;
  margin-right: 4px;
  border-right: 1px solid #374151;
}

.group:last-child {
  border-right: 0;
  padding-right: 0;
}

button, select {
  border: 1px solid #4b5563;
  background: #111827;
  color: #f3f4f6;
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 13px;
  cursor: pointer;
}

button:hover, select:hover {
  border-color: #9ca3af;
}

button.primary {
  background: var(--accent);
  border-color: #1e40af;
}

.editor-wrap {
  overflow: auto;
  padding: 24px;
  background: #0b1220;
}

.page {
  max-width: 860px;
  min-height: calc(100% - 4px);
  margin: 0 auto;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 10px 24px rgba(0,0,0,0.22);
  color: var(--text);
  padding: 36px 44px;
  outline: none;
  line-height: 1.5;
  font-size: 16px;
}

.page:empty:before {
  content: attr(data-placeholder);
  color: #9ca3af;
}

.statusbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--panel);
  border-top: 1px solid #374151;
  color: #d1d5db;
  font-size: 12px;
}

.muted {
  color: var(--muted);
}
`;

// ../../sandbox/1770684810395/src/utils.ts
var STORAGE_KEY = "word-lite-document-v1";
function debounce(fn, delay = 500) {
  let timer = null;
  return (...args) => {
    if (timer) window.clearTimeout(timer);
    timer = window.setTimeout(() => fn(...args), delay);
  };
}
function countTextStats(text) {
  const trimmed = text.trim();
  const words = trimmed ? trimmed.split(/\s+/).length : 0;
  return {
    words,
    chars: text.length
  };
}
function downloadFile(filename, content, type) {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
function nowLabel() {
  return (/* @__PURE__ */ new Date()).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}

// ../../sandbox/1770684810395/src/main.ts
var app = document.getElementById("app") || document.body;
app.innerHTML = `
  <style>${styles}</style>
  <div class="app-shell">
    <div class="topbar">
      <div class="brand"><span class="brand-badge">W</span> Word Lite</div>
      <div class="muted">Simple document editor</div>
    </div>

    <div class="toolbar">
      <div class="group">
        <button data-cmd="bold"><b>B</b></button>
        <button data-cmd="italic"><i>I</i></button>
        <button data-cmd="underline"><u>U</u></button>
      </div>

      <div class="group">
        <select id="format-block" title="Style">
          <option value="P">Paragraph</option>
          <option value="H1">Heading 1</option>
          <option value="H2">Heading 2</option>
          <option value="H3">Heading 3</option>
          <option value="BLOCKQUOTE">Quote</option>
        </select>
      </div>

      <div class="group">
        <button data-cmd="justifyLeft">Left</button>
        <button data-cmd="justifyCenter">Center</button>
        <button data-cmd="justifyRight">Right</button>
        <button data-cmd="insertUnorderedList">\u2022 List</button>
        <button data-cmd="insertOrderedList">1. List</button>
      </div>

      <div class="group">
        <button id="btn-link">Link</button>
        <button data-cmd="removeFormat">Clear</button>
        <button data-cmd="undo">Undo</button>
        <button data-cmd="redo">Redo</button>
      </div>

      <div class="group">
        <button id="btn-new">New</button>
        <button id="btn-open">Open</button>
        <button id="btn-save" class="primary">Save</button>
        <button id="btn-export-txt">.txt</button>
        <button id="btn-export-html">.html</button>
      </div>
    </div>

    <div class="editor-wrap">
      <article id="editor" class="page" contenteditable="true" spellcheck="true" data-placeholder="Start typing..."></article>
      <input id="file-input" type="file" accept=".txt,.html,.htm" style="display:none" />
    </div>

    <div class="statusbar">
      <span id="stats">0 words \u2022 0 chars</span>
      <span id="save-state">Not saved</span>
    </div>
  </div>
`;
var editor = document.getElementById("editor");
var fileInput = document.getElementById("file-input");
var statsEl = document.getElementById("stats");
var saveState = document.getElementById("save-state");
var formatBlock = document.getElementById("format-block");
var exec = (cmd, value) => {
  editor.focus();
  document.execCommand(cmd, false, value);
  refreshStats();
};
var refreshStats = () => {
  const { words, chars } = countTextStats(editor.innerText || "");
  statsEl.textContent = `${words} words \u2022 ${chars} chars`;
};
var saveDoc = () => {
  localStorage.setItem(STORAGE_KEY, editor.innerHTML);
  saveState.textContent = `Saved at ${nowLabel()}`;
};
var autoSave = debounce(() => {
  saveDoc();
}, 550);
var loadDoc = () => {
  const stored = localStorage.getItem(STORAGE_KEY);
  if (stored) {
    editor.innerHTML = stored;
    saveState.textContent = "Loaded saved draft";
  } else {
    editor.innerHTML = "<h1>Untitled Document</h1><p></p>";
    saveState.textContent = "New document";
  }
  refreshStats();
};
for (const btn of Array.from(document.querySelectorAll("button[data-cmd]"))) {
  btn.addEventListener("click", () => {
    const cmd = btn.dataset.cmd;
    exec(cmd);
  });
}
formatBlock.addEventListener("change", () => {
  exec("formatBlock", formatBlock.value);
});
document.getElementById("btn-link")?.addEventListener("click", () => {
  const link = prompt("Enter URL (https://...)");
  if (!link) return;
  exec("createLink", link);
});
document.getElementById("btn-new")?.addEventListener("click", () => {
  const ok = confirm("Start a new blank document?");
  if (!ok) return;
  editor.innerHTML = "<p></p>";
  refreshStats();
  saveState.textContent = "Unsaved new document";
  editor.focus();
});
document.getElementById("btn-open")?.addEventListener("click", () => {
  fileInput.value = "";
  fileInput.click();
});
document.getElementById("btn-save")?.addEventListener("click", () => {
  saveDoc();
});
document.getElementById("btn-export-txt")?.addEventListener("click", () => {
  downloadFile("document.txt", editor.innerText || "", "text/plain;charset=utf-8");
});
document.getElementById("btn-export-html")?.addEventListener("click", () => {
  const html = `<!doctype html><html><head><meta charset="utf-8"><title>Document</title></head><body>${editor.innerHTML}</body></html>`;
  downloadFile("document.html", html, "text/html;charset=utf-8");
});
fileInput.addEventListener("change", async () => {
  const file = fileInput.files?.[0];
  if (!file) return;
  const text = await file.text();
  if (/\.html?$/i.test(file.name)) {
    editor.innerHTML = text;
  } else {
    const escaped = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
    editor.innerHTML = `<p>${escaped}</p>`;
  }
  refreshStats();
  saveState.textContent = `Opened ${file.name}`;
  saveDoc();
});
editor.addEventListener("input", () => {
  refreshStats();
  saveState.textContent = "Editing\u2026";
  autoSave();
});
editor.addEventListener("keyup", refreshStats);
document.addEventListener("keydown", (e) => {
  if (!e.ctrlKey && !e.metaKey) return;
  const key = e.key.toLowerCase();
  if (key === "s") {
    e.preventDefault();
    saveDoc();
  } else if (key === "b") {
    e.preventDefault();
    exec("bold");
  } else if (key === "i") {
    e.preventDefault();
    exec("italic");
  } else if (key === "u") {
    e.preventDefault();
    exec("underline");
  }
});
loadDoc();
editor.focus();
var appApi = window.yaar?.app;
function setEditorFromPlainText(text) {
  const escaped = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
  editor.innerHTML = `<p>${escaped}</p>`;
  refreshStats();
}
if (appApi) {
  appApi.register({
    appId: "word-lite",
    name: "Word Lite",
    state: {
      html: {
        description: "Current document HTML content",
        handler: () => editor.innerHTML
      },
      text: {
        description: "Current document plain text content",
        handler: () => editor.innerText || ""
      },
      stats: {
        description: "Current text stats as { words, chars }",
        handler: () => countTextStats(editor.innerText || "")
      },
      saveState: {
        description: "Current save status label",
        handler: () => saveState.textContent || ""
      }
    },
    commands: {
      setHtml: {
        description: "Replace document with HTML. Params: { html: string }",
        params: {
          type: "object",
          properties: { html: { type: "string" } },
          required: ["html"]
        },
        handler: (p) => {
          editor.innerHTML = p.html || "<p></p>";
          refreshStats();
          saveState.textContent = "Updated via app protocol";
          saveDoc();
          return { ok: true };
        }
      },
      setText: {
        description: "Replace document with plain text. Params: { text: string }",
        params: {
          type: "object",
          properties: { text: { type: "string" } },
          required: ["text"]
        },
        handler: (p) => {
          setEditorFromPlainText(p.text || "");
          saveState.textContent = "Updated via app protocol";
          saveDoc();
          return { ok: true };
        }
      },
      appendText: {
        description: "Append plain text to the document. Params: { text: string, newline?: boolean }",
        params: {
          type: "object",
          properties: {
            text: { type: "string" },
            newline: { type: "boolean" }
          },
          required: ["text"]
        },
        handler: (p) => {
          const existing = editor.innerText || "";
          const next = p.newline === false ? `${existing}${p.text}` : `${existing}${existing ? "\n" : ""}${p.text}`;
          setEditorFromPlainText(next);
          saveState.textContent = "Updated via app protocol";
          saveDoc();
          return { ok: true };
        }
      },
      newDocument: {
        description: "Clear current document to a blank paragraph. Params: {}",
        params: { type: "object", properties: {} },
        handler: () => {
          editor.innerHTML = "<p></p>";
          refreshStats();
          saveState.textContent = "Unsaved new document";
          return { ok: true };
        }
      },
      saveDraft: {
        description: "Save current document to local draft storage. Params: {}",
        params: { type: "object", properties: {} },
        handler: () => {
          saveDoc();
          return { ok: true, savedAt: nowLabel() };
        }
      }
    }
  });
}

  </script>
</body>
</html>